## 问题

Qt中的signals和slots的内部原理是什么？

(字节二面题)

## 解答

<img src="https://raw.githubusercontent.com/xn1997/picgo/master/Qt%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD.svg" alt="Qt信号和槽" style="zoom:150%;" />

### MOC预编译

[qt中的moc](https://www.cnblogs.com/wzxNote/p/8341006.html) 全称是 Meta-Object Compiler，也就是“元对象编译器”，当我们编译C++文件时，如果类声明中包含了宏Q_OBJECT，则会生成另外一个C++源文件，也就是我们经常看到的moc_xxx.cpp文件，执行流程可能会像这样。

![img](https://images.cnblogs.com/cnblogs_com/swarmbees/1454266/o_cl.png)

Q_OBJECT是一个非常重要的宏，他是Qt实现元编译系统的一个关键宏，这个宏展开后，里边包含了很多Qt帮助我们写的代码，包括了变量定义、函数声明等等。

**在程序预处理阶段，会先进行moc预处理，将含有Q_OBJECT宏的类进行扩展，即将Qt帮助写的相关的代码添加进该类之中，并把扩展后的代码保存为moc文件。**

#### moc添加的内容

打开Q_OBJECT的宏可以看到主要添加的内容如下：

声明了一个只读的**静态成员变量staticMetaObject（记录了各种元信息）**，以及3个public的成员函数

```cpp
static const QMetaObject staticMetaObject; 

virtual const QMetaObject *metaObject() const; 
virtual void *qt_metacast(const char *); 
virtual int qt_metacall(QMetaObject::Call, int, void **);
```

还有一个private的**静态成员函数qt_static_metacall**

```cpp
static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **)
```

**staticMetaObject**是一个结构体（类型为QMetaObject），用来**存储类的信号、槽等元信息**，并把qt_static_metacall静态函数作为函数指针存储起来；因为是静态成员，所以实例化多少个对象，它们的元信息都是一样的。

**qt_static_metacall**根据函数索引调用槽函数，这个回调中，信号和槽都是可以被回调的。

#### 信号函数（SIGNAL）的自动实现代码

如下所示为miao信号的实现，0就是miao这个信号的索引号**（该索引号也就标记了该信号，即每个信号都会对应一个唯一的索引号，用于查找与其链接的槽函数）**

```cpp
// SIGNAL 0
void Tom::miao()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr);
}
```

其中`QMetaObject::activate`函数的实现思路为：
找出与该信号连接的所有槽函数，然后挨个处理这些槽函数即可。（具体以什么顺序处理也有区别，分为多种，详情看下面的《信号触发》一节）

### connect机制

以下为connect的流程示意图，可以看出，connect干的事情并不多，好像就是构造了一个Connection对象，**然后存储在了发送者的内存中**，其中存储的主要内容就是发送者（类）、信号索引、接受者（类）、槽函数等，根据这些内容构建出信号和槽的链接关系。

![img](https://www.cnblogs.com/images/cnblogs_com/swarmbees/1454266/o_connect.png)

首先要了解一个前提：信号函数会被分配一个唯一的索引号，槽函数也会被分配一个唯一的索引号，**通过索引号就可以找到对应的函数**。

**connect的功能就是将信号和槽建立一个映射表**，以便可以在调用信号的时候直接找到对应的槽函数，具体实现方式为：

1. 构建一个数组，并将信号的索引号作为数组的下标
2. 由于一个信号可以链接多个槽，那么数组中存储的是一个链表，这样也就方便插入和删除槽函数

以下为示意图：

<img src="https://raw.githubusercontent.com/xn1997/picgo/master/image-20210708225958492.png" alt="image-20210708225958492" style="zoom:70%;" />

在具体程序中，以上这个数组+链接并结构为`QObjectConnectionListVector`，而单独一个链表为`CommectionList`，即

````cpp
class QObjectConnectionListVector : public QVector<QObjectPrivate::ConnectionList>
````

### 信号触发

通过connect将信号和槽建立链接之后，当发射信号时（即执行`emit testSignal();`），根据信号函数的实现代码可以看出，信号会自动去执行`QMetaObject::activate()`函数调用槽函数。具体流程如下图：

1. 发射信号。
2. 调用`QMetaObject::activate()`函数。
3. 根据信号找到与其链接的槽函数。
4. 由于槽函数有多个，因此需要进行循环处理，直到调用完所有的槽函数。这里各个槽的调用顺序是有区别的，下一节介绍。

<img src="https://www.cnblogs.com/images/cnblogs_com/swarmbees/1454266/o_emit_signals.png" alt="img" style="zoom:100%;" />

### 槽的调用顺序

#### 直连

当信号和槽处于同一个线程时，使用直连方法。

就是函数回调，直接根据记录在发送者的槽函数地址调用槽函数即可。（《connect机制一节》写道connect会将记录了槽函数和信号函数的connection对象保存在发送者内部，因此当发送者使用信号时，就可以根据connection对象找到对应链接的槽函数地址，并通过该地址调用槽函数）

#### 队列连接

当信号和槽处于不同的线程是，使用队列连接。

信号发送时，槽函数的执行是通过抛出一个事件到事件队列中，经过事件循环来调用槽函数，由于事件循环的异步性，因此这里的槽函数也是异步执行的，不同于直连的立即运行。

#### 阻塞队列链接

槽函数也是使用事件循环调用的，不过区别是：在信号发出后，信号所在线程会被阻塞，直到槽函数执行完毕，信号所在线程才会开始进行运行，而队列链接在抛出事件后就会直接运行后续的程序，不会发生阻塞。

### 总结

信号槽的**实现原理就是函数回调**，不同是直连直接进行函数回调，而队列链接使用Qt的事件循环隔离了一次达到了异步的效果，但本质还是要使用函数回调。

1. signals和slots就是为了方便moc解析我们的C++文件，从中解析出信号和槽。
2. 信号和槽的本质都是函数，但**信号只要声明，不需要写实现**，这是因为moc会为我们自动生成。**槽函数需要自己声明和实现**，moc不会帮助实现。触发信号时，不写emit关键字，直接调用信号函数，也是没有问题的，这是因为emit是一个空的宏。
3. connect方法就是把发送者、信号、接受者和槽存储起来，供后续执行信号时查找。
4. 信号触发就是一系列**函数回调**。

## 信号槽机制的简介

既然槽是普通的成员函数，因此与其它的函数一样，它们也有存取权限。槽的存取权限决定了谁能够与其相关联。同普通的 C++ 成员函数一样，**槽函数也分为三种类型**，即 public slots、private slots 和 protected slots。

**public slots：**在这个区内声明的槽意味着任何对象都可将信号与之相连接。这对于组件编程非常有用，你可以创建彼此互不了解的对象，将它们的信号与槽进行连接以便信息能够正确的传递。
**protected slots：**在这个区内声明的槽意味着当前类及其子类可以将信号与之相连接。这适用于那些槽，它们是类实现的一部分，但是其界面接口却面向外部。
**private slots：**在这个区内声明的槽意味着只有类自己可以将信号与之相连接。这适用于联系非常紧密的类。——项目里，将cam的发送图片信号和界面的显示槽函数链接就是使用的这个私有类型。



所谓**信号槽，实际就是观察者模式**。当某个事件发生之后，比如，按钮检测到自己被点击了一下，它就会发出一个信号（signal）。这种**发出是没有目的的，类似广播**。如果有对象对这个信号感兴趣，它就会使用连接（connect）函数，意思是，将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号。也就是说，**当信号发出时，被连接的槽函数会自动被回调**。

1. 槽的本质是类的成员函数，其参数可以是任意类型的。和普通C++成员函数几乎没有区别，它可以是虚函数；也可以被重载；可以是公有的、保护的、私有的、也可以被其他C++成员函数调用。**唯一区别的是：槽可以与信号连接在一起**，每当和槽连接的信号被发射的时候，就会调用这个槽。
2. （1）发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；
   （2）使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；
   （3）槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；
   （6）**任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数**。

**信号槽的多种用法：**
（1）一个信号可以和多个槽相连
　　如果是这种情况，这些槽会一个接一个的被调用，但是它们的**调用顺序是不确定的**。
（2）多个信号可以连接到一个槽
　　只要任意一个信号发出，这个槽就会被调用。
（3）一个信号可以连接到另外的一个信号
　　当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。
（4）槽可以被取消链接
　　这种情况并不经常出现，因为当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽。
（5）使用Lambda 表达式
　　在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。

## 信号-槽机制的优点

（1）问题：
为什么Qt使用信号与槽机制而不是传统的回调函数机制进行对象间的通信呢？
回调函数的本质是“你想让别人的代码执行你的代码，而别人的代码你又不能动”这种需求下产生的。
**回调函数是函数指针的一种用法**，如果多个类都关注某个类的状态变化，此时需要维护一个列表，以存放多个回调函数的地址。对于每一个被关注的类，都需要做类似的工作，因此这种做法效率低，不灵活。

（2）解决办法：
Qt使用信号与槽机制来解决这个问题，程序员只需要指定一个类含有哪些信号函数、哪些槽函数，Qt会处理信号函数和槽函数之间的绑定。当信号函数被调用时，Qt会找到并执行与其绑定的槽函数。允许一个信号函数和多个槽函数绑定，Qt会依次找到并执行与一个信号函数绑定的所有槽函数，这种处理方式更灵活。

（3）优点:
**Qt信号与槽机制降低了Qt对象的耦合度**

## 信号和槽的连接方式（即槽调用的规则顺序）

通过connect函数的第五个参数connectType来控制。

Qt::AutoConnection： 默认值，使用这个值则连接类型会在信号发送时决定。如果接收者和发送者在同一个线程，则自动使用Qt::DirectConnection类型。如果接收者和发送者不在一个线程，则自动使用Qt::QueuedConnection类型。

**Qt::DirectConnection（直连）**：槽函数会在信号发送的时候直接被调用，槽函数运行于信号发送者所在线程。效果看上去就像是直接在信号发送位置调用了槽函数。这个在多线程环境下比较危险，可能会造成奔溃。

**Qt::QueuedConnection（队列）**：槽函数在控制回到接收者所在线程的事件循环时被调用，槽函数运行于信号接收者所在线程。发送信号之后，槽函数不会立刻被调用，等到接收者的当前函数执行完，进入事件循环之后，槽函数才会被调用。多线程环境下一般用这个。

Qt::BlockingQueuedConnection：槽函数的调用时机与Qt::QueuedConnection一致，不过发送完信号后发送者所在线程会阻塞，直到槽函数运行完。接收者和发送者绝对不能在一个线程，否则程序会死锁。在多线程间需要同步的场合可能需要这个。

Qt::UniqueConnection：这个flag可以通过按位或（|）与以上四个结合在一起使用。当这个flag设置时，当某个信号和槽已经连接时，再进行重复的连接就会失败。也就是避免了重复连接。

## 事件循环

需求: 程序能够一直运行，每次用户输入一些信息并按下回车时，打印出用户的输入。直到输入的内容为“quit”时才退出。
代码实现如下：

```cpp
#include <stdio.h>
#include <string.h>
int main(int argc, char* argv[])
{
    char input[1024];   //假设输入长度不超过1024
    const char quitStr[] = "quit";
    bool quit = false;
    while (false == quit) {
        scanf_s("%s", input, sizeof input);
        printf("user input: %s\n", input);
        if (0 == memcmp(input, quitStr, sizeof quitStr)) {
            quit = true;
        }
    }
    return 0;
}
```

我们使用了一个while循环。在这个循环体内，不停地处理用户的输入。当输入的内容为”quit”时，循环终止条件被设置为true，循环将终止。

“用户输入并按下回车”这件事情，我们可以称作一个“事件”，不停的去处理“事件”的这段代码，称作“**事件循环**”。对于带UI窗口的程序来说，“事件”是由操作系统或程序框架在不同的时刻发出的，比如按下鼠标、点击按钮等操作。

事件循环中，需要不停的获取下一个事件，然后处理。而事件一般有多个，因此事件会被保存在一个队列之中，称之为**事件队列**，**事件循环的过程就是：每次从事件队列中获取一个事件，然后处理，即一次循环只处理一个事件。因此当事件触发后，不是立即执行，而是被加入事件队列，经过事件循环来执行，也就是异步执行。**
事件循环的伪代码如下：

```cpp
function loop() {
    initialize();
    bool shouldQuit = false;
    while(false == shouldQuit) // 执行事件循环
    {
        var message = get_next_message(); // 从事件队列中获取一个事件
        process_message(message); // 处理该事件
        if (message == QUIT) 
        {
            shouldQuit = true;
        }
    }
}
```

## 如果事件处理时间太长怎么办（QThread的使用）

根据事件循环机制可以看出，如果一个事件没有执行完，是不会处理下一个事件的，因此事件的处理是阻塞的。解决方法就是将该事件的处理过程移到另一个线程中执行，这样就避免了阻塞——扶梯项目中，就是将cam1/2/3/4四个处理进程放在QThread的run()函数中，这样通过多线程执行各个处理程序的同时，不会影响主线程的显示和其他操作过程。

**使用QThread机制解决该问题**

1. 主线程是运行GUI相关的程序，比如事件循环，一直检测按钮是否被按下，界面显示的内容是否更新等等。
2. 如果某一个按钮按下后对应的处理函数fun非常耗时，那么这个处理程序fun就不应该放在主线程中，而是继承QThread类，然后重写run()，即将fun写入run()
3. 将按钮触发对应的处理函数改为调用这个QThread线程类，即再次按下按钮时，会开启一个新的线程，而fun就在这个新的线程中运行，这样就可以避免阻塞主线程。

**在扶梯项目中的运用**

1. 由于cam123各个线程并不是由按钮触发的，所以使用QThread的目的不是为了解决主线程阻塞问题，而是因为项目本身就需要使用多个线程来分别完成多个任务。
2. 由于cam1中涉及到将处理后的图像在主线程中运行的GUI界面进行显示，因此就需要将cam1的处理图像发送给主线程的界面显示函数，而这就设计到了**线程之间的通信**，而QT使用了信号槽机制来完成不同线程间的通信，所以cam1继承了QThread，而不是普通的多线程库（如threads）。
3. 根据通信需求，在cam1中声明一个信号函数（参数为待显示图片的数据类型），在主线程中实现一个槽函数，即GUI显示函数（参数与信号函数一致），然后使用connect函数将信号和槽链接起来，这样当cam1线程发送信号时，主线程就可以接受到该参数然后显示了。

#### 参考链接

[PyQT5线程：多线程(QThread)，线程锁(QMutex)](https://zhuanlan.zhihu.com/p/62988456)——以例子讲解QT中多线程的使用

## 参考链接

[Qt信号槽-原理分析](https://www.cnblogs.com/swarmbees/p/10816139.html)——主要参考了这一个，信息比较全

[Qt原理-窥探信号槽的实现细节](https://zhuanlan.zhihu.com/p/80539605)——知乎大佬，讲的通俗易懂，且有很多相关的文章，建议仔细阅读。

[Qt 之 信号槽机制及优缺点](https://blog.csdn.net/QIJINGBO123/article/details/86155060)——总结了优缺点，可以面试用

# 扩展

## 函数回调

函数回调就是一种双向调用机制

<img src="https://pic2.zhimg.com/80/v2-52274c878b188143ee8f3cddd2597981_720w.jpg" alt="img" style="zoom:50%;" />

使用场景就是：A实现了一个方法，而这个方法是在B中调用，但是A不知道B什么时候调用该方法，因此A就将该方法直接交给B（**将该函数的地址传给B**），由B决定什么时候调用该方法。
A把方法给B后就可以继续向下执行了，B也进行，这样就**实现了AB的并行起到了加速效果**，而B在执行完毕后告诉A即可，A再进行相应的处理。

下图左侧为同步调用，右侧为异步调用，而异步调用就是函数回调的运用。

<img src="https://pic1.zhimg.com/80/v2-9161e56847087ead6cc892ecf52b5eb4_720w.jpg" alt="img" style="zoom:50%;" /><img src="https://pic1.zhimg.com/80/v2-3e2ceb4b054ae956c7422547a76ff660_720w.jpg" alt="img" style="zoom:50%;" />

### 参考链接

[10张图让你彻底理解回调函数](https://zhuanlan.zhihu.com/p/326902537)