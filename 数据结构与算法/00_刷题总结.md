# 剑指offer

## 队列或桟以O(1)实现求max和min

题目:![](./image/剑指offer30-59.png)

当涉及到队列或者桟实现max和min的O(1)时,一定需要借助辅助变量
1. 桟: 使用**辅助桟**
	1.1. 只压入比当前辅助桟top大的数,反向弹出
2. 队列queue: 使用**辅助双端队列deque**
	2.1. 与queue压入顺序一致,从后往前插入
	2.2. 当压入数据不比back数据大时,直接压入
	2.3. 当比back数据大时,循环弹出back,直到back大于等于压入数据,或者deque为空时,再压入

- 使用场景
  - 滑动窗不断的移动，并求各个滑动窗的最大值

## 快速幂的求解方法

暂时不理解Leecode的解析，后面再仔细学习

## 二分法示例

```cpp
/**
*   二分法查找数组中，某个数的右边界, 返回边界
*/
int binary_search(vector<int>& nums, int target){
    // 初始化搜索边界
    int i = 0, j = nums.size() - 1;
    while(i < j){
        // 判断中间位置,向下取整
        int mid = (i + j) / 2;
        if(nums[mid] <= target) // 保证搜索范围内的数都大于目标值
            i = mid + 1;
        else
            j = mid - 1;
    }
    // 此时，必定i=j + 1
    return i;
}
```

## 位运算表示加法

重点学习：剑指offer65

> 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。

```cpp
class Solution {
public:
    // 参考解析理解位运算
    /** 加法=异或+(与且<<1)
    *
    */
    int add(int a, int b) {
        while(b != 0){
            //C++中负数不支持左移位，因为结果是不定的
            int c = (unsigned int)(a & b) << 1; // 进位和，当无进位时c就为0，跳出循环
            a ^= b; // 异或等同于没有进位的加法
            b = c; 
        }
        return a;
    }
};
```

## 约瑟夫环问题

[剑指 Offer 62. 圆圈中最后剩下的数字](https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/)

假设dp[n]为[n, m]问题剩下的最后一个数，其中初始化条件dp[1]=0
$$
\begin{array}{rl}
dp[n]: &0,1,2,...,n-1 \\
& t,t+1,t+2,...,0,1,2,...,t-2\\
dp[n-1]:&0,1,2,...,n-2 \\
\end{array}.
$$
如上：

1. 第一行为dp[n]时对应的待删除数组
2. 删除数$(m-1)\%n$后，并把后一个数$t=m\%n$移动到开头，得到新的队列，也就是第二行
3. 第三行是dp[n-1]时对应的待删除数组，将第二行n-1个数，与dp[n-1]时的坐标进行对比，可以得到dp[n-1]到dp[n]同一索引下数值的对应关系。

$$
\begin{aligned}{}
dp[n]&=(dp[n-1]+t)\%n \\
&=(dp[n-1]+m)\%n
\end{aligned}
$$

至此找到了初始状态dp[1]=0，状态转移公式，因此可以写出程序如下

```C++
class Solution {
public:
    int lastRemaining(int n, int m) {
        int ret = 0;
        for(int i=2; i<=n; i++){
            ret = (ret + m) % i;
        }
        return ret;
    }
};
```

## 区间合并问题

[56. 合并区间](https://leetcode-cn.com/problems/merge-intervals/)

[我的题解](https://leetcode-cn.com/problems/merge-intervals/solution/56-he-bing-qu-jian-by-shou-hu-w9-guqn/)

[🤷‍♀️必须秒懂力扣区间题目：重叠区间、合并区间、插入区间](https://mp.weixin.qq.com/s/ioUlNa4ZToCrun3qb4y4Ow)（总结了所有的区间题型）

## 链表问题总结（环，中间元素，链表排序）

[一文搞定常见的链表问题 (欢迎交流](https://leetcode-cn.com/problems/linked-list-cycle/solution/yi-wen-gao-ding-chang-jian-de-lian-biao-wen-ti-h-2/)

**链表排序：归并排序**

[148. 排序链表](https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-by-shou-hu-w9-pnj3/)（我的题解）

**查找入环结点**

判断是否有环+查找入环点

[142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/142-huan-xing-lian-biao-ii-by-shou-hu-w9-n15q/)（我的题解）

## 计算器

实现带括号的加减乘除操作（字节）

[224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/solution/224-ji-ben-ji-suan-qi-by-shou-hu-w9-hns1/)（我的题解）

## 排列组合（回溯算法）

[C++ 总结了回溯问题类型 带你搞懂回溯算法(大量例题)](https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/)

1. 画出递归树，根据树寻找状态变量（DFS函数的传入参数）
2. 寻找递归条件

- **排列，**如果选过的不可以再选，应该使用`vector<bool>used`记录遍历过的点，防止下次继续遍历
- **组合，**如果存在有顺序的搜索，应该使用`start`标记搜索数组的开始位置，避免重复搜索

# 必备代码

## 字符串分割为数组

```cpp
vector<string> split(string &str, const string &pattern)
{
    vector<string> res;
    int pos;
    str += pattern;
    int sz = str.size();
    for (int i = 0; i < sz; i++)
    { // i指向查找起始位置
        pos = str.find(pattern, i);
        string s = str.substr(i, pos - i);
        res.push_back(s);
        i = pos + pattern.size() - 1; // 更新i指向下一个位置
    }
    return res;
}
```



# 题型总结

## 递归

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = dp[1] = 1;
        for(int i=2; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution
{
public:
    /* 判断当前结点是否是叶子结点：
        叶子结点+targetSum=root->val：true
        其余为false
    */
    bool hasPathSum(TreeNode *root, int targetSum)
    {
        if (root == nullptr)
            return false;
        if (root->left == nullptr && root->right == nullptr && targetSum == root->val)
        {
            return true;
        }
        return hasPathSum(root->left, targetSum - root->val) || hasPathSum(root->right, targetSum - root->val);
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/path-sum/solution/112-lu-jing-zong-he-by-shou-hu-w9-3xl6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [509. 斐波那契数](https://leetcode-cn.com/problems/fibonacci-number/)

```cpp
class Solution {
public:
    int fib(int n) {
        if(n <= 1) return n;
        int dp[n+1];
        dp[0]=0; dp[1]=1;
        for(int i=2; i<=n; i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];
    }
};
```

#### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

递归：沉岛算法
可以解决的问题有：

1. 每个岛屿的面积
2. 岛屿的数量（计算完面积后，只有岛屿面积不为0就认为是一个岛屿）
3. 被包围的区域（第130题）

```cpp
class Solution {
public:
    /*  求出每个岛屿的面积-->岛屿的面积使用递归求解
        当前点所在岛屿的面积 = 周围点所在岛屿面积 之和 + 1（1就是当前点的面积）
            为了保证当前点不影响周围点面积的计算，遍历后需要将1变为0，也就是沉岛方法。
    */
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        rows = grid.size();
        cols = grid[0].size();
        int res = 0;
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                res = max(res, dfs(grid, i, j));
            }
        }
        return res;
    }
    int dfs(vector<vector<int>>& grid, int x, int y){
        if(x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] == 0) // 遍历到水就直接返回，面积为0
            return 0;
        grid[x][y] = 0; // 沉岛，防止后续递归重新遍历到该点
        int res = 1;
        res += dfs(grid, x+1, y);
        res += dfs(grid, x-1, y);
        res += dfs(grid, x, y-1);
        res += dfs(grid, x, y+1);
        return res;
    }
private:
    int rows;
    int cols;
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/max-area-of-island/solution/695-dao-yu-de-zui-da-mian-ji-by-shou-hu-etct6/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

递归：沉岛算法（和695一个思路，只不过这里只需要计算边缘位置的连通域）

并查集解法请看下面《并查集一节》

```cpp
class Solution {
public:
    /*  查找出边缘位置的连通域，标记使其不变即可
        所以写出一个查找连通域的函数即可(沉岛算法即可)
    */
    void solve(vector<vector<char>>& board) {
        rows = board.size();
        cols = board[0].size();
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                // 只对边缘位置查找连通域
                if(i==0 || j==0 || i==rows-1 || j==cols-1){
                    if(board[i][j] == 'O')
                        dfs(board, i, j);
                }
            }
        }
        // 按照要求修改标志位
        for(int i=0; i<rows; i++){
            for(int j=0; j<cols; j++){
                if(board[i][j] == 'O')
                    board[i][j] = 'X';
                else if(board[i][j] == '#')
                    board[i][j] = 'O';
            }
        }
    }

    void dfs(vector<vector<char>>& board, int x, int y){
        if(x < 0 || x >= rows || y < 0 || y >= cols || board[x][y] == 'X' || board[x][y] == '#') // 遍历到X就直接返回
            return;
        board[x][y] = '#'; // 进行标记
        dfs(board, x+1, y);
        dfs(board, x-1, y);
        dfs(board, x, y-1);
        dfs(board, x, y+1);
        return;
    }
private:
    int rows;
    int cols;
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/surrounded-regions/solution/130-bei-wei-rao-de-qu-yu-by-shou-hu-w9-jnfp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

```cpp
class Solution {
public:
    /*  遍历问题：递归+回溯
        画出递归树，状态遍历为：
            1. 当前遍历的起点位置xy
            2. 当前待查字符的位置begin
            3. 已经添加到路径中的单元格
        回溯：当前待检测的方向（上下左右）
        返回：是否存在
    */
    bool exist(vector<vector<char>>& board, string word) {
        m = board.size();
        n = board[0].size();
        len = word.size();
        for(int i = 0; i < m; i++){
            for(int j = 0; j < n; j++){
                vector<vector<bool>> visited(m, vector<bool>(n, false));
                if(dfs(board, word, i, j, 0, visited)){
                    return true;
                }
            }
        }
        return false;
    }
private:
    vector<vector<int>> DIRECTION{{1,0},{0,-1},{-1,0},{0,1}}; // 搜索方向
    int m, n, len;
    bool dfs(vector<vector<char>>& board, string& word, int x, int y, int begin, vector<vector<bool>>& visited){
        // 退出条件*****
        if(begin == len - 1){
            return board[x][y] == word[begin]; // 如果最后一个字符相同，就退出
        }
        // 递归条件
        if(board[x][y] == word[begin]){ // 匹配成功，进入下个递归
            visited[x][y] = true;
            for(int i=0; i<4; i++){
                int new_x = x + DIRECTION[i][0];
                int new_y = y + DIRECTION[i][1];
                // 如果当前位置未被遍历，且下一个位置没有超出边界就进行递归搜索
                if(new_x >= 0 && new_x < m && new_y >= 0 && new_y < n && !visited[new_x][new_y]){
                    // 找到了就直接返回，不在遍历其他位置******
                    if(dfs(board, word, new_x, new_y, begin+1, visited)){
                        return true;
                    }
                }
            }
            visited[x][y] = false; // 回溯
        }
        return false; // 如果没有找到就返回false
    }
};
```



## 分治

递归思想，将问题逐渐化为多个子问题，一级一级的搜索即可。

<font color='red'>形参必定包含搜索范围。</font>

#### [LCP 23. 魔术排列](https://leetcode-cn.com/problems/er94lq/)——未做

#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

学习分治思想可以用下面的分治，但建议用摩尔投票。

```cpp
class Solution
{
public:
    /*  分治
    如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。
    因此，每次将数据分为左右两部分（需要标记左右区间），分别计算各自的众数
        如果左右众数相同，则众数就是这个
        不同，就查找谁出现的次数多，就是谁
    */
    int majorityElement(vector<int> &nums)
    {
        return recur(nums, 0, nums.size()-1);
    }

private:
    int recur(vector<int> &nums, int left, int right)
    {
        if (left == right) // 只有一个元素，自然而然该数就是众数
            return nums[left];
        int mid = left + (right - left) / 2;
        int left_majority = recur(nums, left, mid);
        int right_majority = recur(nums, mid + 1, right);
        if (left_majority == right_majority)
            return left_majority;
        if (countInRange(nums, left_majority, left, mid) > countInRange(nums, right_majority, mid + 1, right))
        {
            return left_majority;
        }
        else
        {
            return right_majority;
        }
    }
    // 计算目标元素的数量
    int countInRange(vector<int> &nums, int target, int left, int right)
    {
        int res = 0;
        for (int num : nums)
        {
            if (num == target)
                res++;
        }
        return res;
    }
};

```

摩尔投票方法

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [240. 搜索二维矩阵 II](https://leetcode-cn.com/problems/search-a-2d-matrix-ii/)

```cpp
class Solution {
public:
    /*  BFS 比作二叉搜索树，然后使用BFS查找即可
    将左下角作为根节点，可以发现其上方全是小，右方全是大，就是一个二叉搜索树，因此可以使用BFS的方法，一级一级往下找即可
    */
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int rows = matrix.size();
        int cols = matrix[0].size();
        int r = rows -1; // 指向根节点（左下角）
        int c = 0;
        while(c < cols && r >= 0){
            if(matrix[r][c] > target)
                r--;
            else if(matrix[r][c] < target)
                c++;
            else    
                return true;
        }
        return false;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/240-sou-suo-er-wei-ju-zhen-ii-by-shou-hu-xjcr/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    /*  要给出所有的组合结果，而不是总的组合数，所以要使用递归的思路
    因此，寻找方法将大问题逐级划为相同的子问题。
    思路：
        一个树的种类是由其左右子树的种类决定，而左右子树又可视为一个树，从而可以分别计算左右子树的种类，然后合并二者得到本次数的结果-->分治思想
        二叉搜索树的特点：root>left, root<right，所以如果当前结点为i，那么左树的范围就是[min,i-1]，右树为[i+1,max]
        1. 根据当前结点的取值范围，构建指定范围的搜索树-->使用first/end标记二叉搜索树的范围
        2. 递归构建出左右子树（所有可能的结果，所以是个数组）
        3. 穷举求出该位置的计算结果
    */
    vector<TreeNode*> generateTrees(int n) {
        return generateTrees(1, n);
    }
    vector<TreeNode*> generateTrees(int first, int end) {
        vector<TreeNode*> res;
        if(first > end){
            return {nullptr};
        }
        for(int i=first; i<= end; i++){
            vector<TreeNode*> left = generateTrees(first, i-1);
            vector<TreeNode*> right = generateTrees(i+1, end);
            for(auto l:left){
                for(auto r:right){
                    TreeNode* cur = new TreeNode(i);
                    cur->left = l;
                    cur->right = r;
                    res.emplace_back(cur);
                }
            }
        }
        return res;
    }
};
```



## 单调栈

单调**递增栈**的性质：

元素出栈时，

- 出栈元素**后面的**第一个<font color='red'>小于</font>他的值是入栈元素（右侧边界）
- 出栈元素**前面的**第一个<font color='red'>小于</font>他的值是新栈顶元素（左侧边界）

单调**递减栈**的性质：

元素出栈时，

- 出栈元素**后面的**第一个<font color='red'>大于</font>他的值是入栈元素（右侧边界）
- 出栈元素**前面的**第一个<font color='red'>大于</font>他的值是新栈顶元素（左侧边界）

1. 通常栈内压入的是索引，而索引处的值只作为压栈的条件
2. 需要同时设定一个res，用于在出栈时获取对应的处理结果（结合以下题目理解）

注意：

- 单调递增栈，寻找左右第一个小于其的值，一般**需要在两侧添加辅助的0**，防止左右两侧的目标找不到小于其的值。
- 单调递减栈，寻找左右第一个大的值，一般需要**在while内部判断是否到达边缘**，比如接雨水问题。

#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

使用单调递增栈，寻找每个位置的左右两侧小于其的位置

```cpp
class Solution {
public:
    /*  解题思路：
    对于每一个索引，找出其左右边界（即左右第一个高度小于其的索引），然后该高度*边界差就是该索引对应的高度
    故 需要遍历每一个索引，并得到每个索引对应的矩形面积，并取出其中的最大值。
    - 寻找左右边界的方法有：
    1. 向左右遍历，寻找各自第一个小于其高度的索引，时间复杂度n*n
    2. 使用单调递增栈，其性质为：元素出栈时，
        - 说明出栈元素后面的第一个小于他的值是入栈元素（右侧边界）
        - 说明出栈元素前面的第一个小于他的值是新栈顶元素（左侧边界）
        因此，在出栈的过程中，就可以计算出出栈元素的左右边界，时间复杂度为n
        - 由于需要的是左右边界，因此栈内元素就是索引，而压栈条件就是对应索引的高度
        - 对于两侧元素，由于其各自不存在左右小于其高度的索引，所以直接在两侧添加一个高度为0的索引即可
    */
    int largestRectangleArea(vector<int>& heights) {
        heights.insert(heights.begin(), 0); // 添加左右辅助高度——独有的
        heights.emplace_back(0);
        // 以上为边界进行特殊处理
        int res = 0;
        stack<int> st;
        for(int i=0; i < heights.size(); i++){
            // 出栈以搜索左右边界
            while (!st.empty() && heights[st.top()] > heights[i])
            {
                int cur = st.top(); // 出栈的元素
                st.pop();
                int left = st.top(); // 搜索左右边界
                int right = i;
                res = max(res, (right - left - 1) * heights[cur]);
            }
            // 此时说明，栈顶元素一定比height[i]小
            st.push(i);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-mmqp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

<img src="https://gitee.com/xn1997/picgo/raw/master/1626684722-zTHnhH-image.png" alt="image.png" style="zoom:50%;" />

```cpp
class Solution
{
public:
    /*  解题思路：
    对于每一个索引，找出其左右边界（即左右第一个高度小于其的索引），然后该高度*边界差就是该索引对应的高度
    故 需要遍历每一个索引，并得到每个索引对应的矩形面积，并取出其中的最大值。
    - 寻找左右边界的方法有：
    1. 向左右遍历，寻找各自第一个小于其高度的索引，时间复杂度n*n
    2. 使用单调递增栈，其性质为：元素出栈时，
        - 说明出栈元素后面的第一个小于他的值是入栈元素（右侧边界）
        - 说明出栈元素前面的第一个小于他的值是新栈顶元素（左侧边界）
        因此，在出栈的过程中，就可以计算出出栈元素的左右边界，时间复杂度为n
        - 由于需要的是左右边界，因此栈内元素就是索引，而压栈条件就是感觉索引的高度
        - 对于两侧元素，由于其各自不存在左右小于其高度的索引，所以直接在两侧添加一个高度为0的索引即可
    */
    int largestRectangleArea(vector<int> &heights)
    {
        heights.insert(heights.begin(), 0);
        heights.emplace_back(0);
        // 以上为边界进行特殊处理
        int res = 0;
        stack<int> st;
        for (int i = 0; i < heights.size(); i++)
        {
            // 出栈以搜索左右边界
            while (!st.empty() && heights[st.top()] > heights[i])
            {
                int cur = st.top(); // 出栈的元素
                st.pop();
                int left = st.top(); // 搜索左右边界
                int right = i;
                res = max(res, (right - left - 1) * heights[cur]);
            }
            // 此时说明，栈顶元素一定比height[i]小
            st.push(i);
        }
        // 数据恢复原状
        heights.erase(heights.begin());
        heights.erase(heights.end()-1);
        return res;
    }
    int maximalRectangle(vector<vector<char>> &matrix)
    {
        if(matrix.size() == 0) return 0;
        int res;
        int rows = matrix.size();
        int cols = matrix[0].size();
        vector<int> heights(cols, 0); // 记录每层的高度
        // 逐层计算1的高度
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (matrix[i][j] == '1')
                    heights[j] += 1;
                else
                    heights[j] = 0;
            }
            res = max(res, largestRectangleArea(heights));
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/maximal-rectangle/solution/85-zui-da-ju-xing-by-shou-hu-w9-610w/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

```cpp
class Solution {
public:
    /*  寻找右侧第一个比其大的元素索引
        单调递减栈的性质：
        - 出栈元素后面的第一个大于他的值是入栈元素（右侧边界）
        - 出栈元素前面的第一个大于他的值是新栈顶元素（左侧边界）
    */
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        vector<int> res(temperatures.size(), 0);
        stack<int> st;
        // 遍历压栈
        for(int i=0; i<temperatures.size(); i++){
            while (!st.empty() && temperatures[st.top()] < temperatures[i])
            {
                int cur = st.top(); // 待更新的天
                st.pop();
                int right = i; // 右侧第一个大于其的天
                res[cur] = right - cur;
            }
            st.push(i);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/daily-temperatures/solution/739-mei-ri-wen-du-by-shou-hu-w9-y5jj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

```cpp
class Solution
{
public:
    /*  寻找第一个比其更大的数
        单调递减栈的性质：
            出栈元素右侧第一个比起大的值就是入栈元素
        栈内记录索引
        返回值根据入栈出栈记录对应的返回值
        - 由于是循环数组，因此可以直接把数组复制一遍即可（这里直接对索引取模即可）
    */
    vector<int> nextGreaterElements(vector<int> &nums)
    {
        int sz = nums.size();
        vector<int> res(sz, -1);
        stack<int> st;
        for (int i = 0; i < 2 * sz - 1; i++)
        {
            while (!st.empty() && nums[st.top()] < nums[i % sz])
            {
                int cur = st.top(); // 待更新的位置
                st.pop();
                int right = i % sz; // 第一个比其大的数位置
                res[cur] = nums[right];
            }
            st.push(i % sz);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/next-greater-element-ii/solution/503-xia-yi-ge-geng-da-yuan-su-ii-by-shou-p0sb/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [42. **接雨水**](https://leetcode-cn.com/problems/trapping-rain-water/)

使用单调递减栈：寻找左右第一个大于当前位置的索引，从而计算出当前位置对应的水的高度。
（单调递减栈不需要向两侧添加辅助数字，但可能需要在while内部判断是否到达边缘）

```cpp
class Solution {
public:
    /**
     * 寻找每个位置左右第一个比他大的位置，然后由高度差及宽度计算面积
    */
    int trap(vector<int>& height)
    {
        int res = 0;
        stack<int> st;
        for (int i = 0; i < height.size(); ++i) {
            while (!st.empty() && height[st.top()] < height[i]) {
                int cur = st.top();
                st.pop();
                if (st.empty())
                    break; // 当走到边缘时，不计算面积——这一块是独有的
                int left = st.top();
                int right = i;
                int h = min(height[left], height[right]) - height[cur];
                int w = right - left - 1;
                res += h * w;
            }
            st.push(i);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/42-jie-yu-shui-by-shou-hu-w9-10y4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 并查集

并查集的固定写法。参考链接：[[Python/C++/Java] 多图详解并查集](https://leetcode-cn.com/problems/number-of-provinces/solution/python-duo-tu-xiang-jie-bing-cha-ji-by-m-vjdr/)

**并查集的三个结构**（分别实现这三个函数即可）：
集：由字典组成的数据结构，只记录父节点（这与单链表正好相反）——<font color='red'>如果键为vector必须使用map，使用unordered_map会报错。</font>
并：不同集的合并
查：根据结点查找数的根节点，从而判断两个结点是否属于一个集
最后再添加一个add函数，用于创建新的集。添加一个私有变量用于记录集的数目。

**使用场景：查找连通域的数量。**

使用流程：（参考200题）
<font color='orange'>先初始化出所有可能的集合</font>。如把所有1的位置都设置为一个集
<font color='orange'>再根据条件进行合并</font>。把相邻的1的集合并

```cpp
class UnionFind
{
public:
    // （查）查找根节点+路径压缩
    int find(int x)
    {
        int root = x;
        // 逐级找到根节点
        while (father[root] != -1)
        {
            root = father[root];
        }
        // 此时root为根节点
        // 逐级压缩路径以提高后续的搜索速度(具体看图解，就相当于是链表的替换而已)
        while (x != root) // 必须是x不能是father[x]，当find的输入就是root时即可发现不能是father[x]
        {
            int original_father = father[x];
            father[x] = root;
            x = original_father;
        }
        return root;
    }
    // （并）合并两个树
    void merge(int x, int y)
    {
        int root_x = find(x);
        int root_y = find(y);
        if (root_x != root_y)
        {
            father[root_x] = root_y;
            num_of_sets--;
        }
    }
    // 添加新的树
    void add(int x)
    {
        if (father.count(x) == 0)
        {
            father[x] = -1;
            num_of_sets++;
        }
    }
    int get_num_of_sets()
    {
        return num_of_sets;
    }

private:
    // （集）使用字典记录父节点：当前结点-父节点
    unordered_map<int, int> father;
    int num_of_sets = 0; // 记录数的数目
};
```



#### [547. 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)

```cpp
class Solution
{
public:
    /*  只需查找下三角就可以了，上三角不需要查找，内容一样
    使用并查集：
        1. 
    */
    int findCircleNum(vector<vector<int>> &isConnected)
    {
        UnionFind uf;
        for (int i = 0; i < isConnected.size(); i++)
        {
            uf.add(i); // 创建新树
            for (int j = 0; j < i; j++)
            { // 判断新树与老树直接是否应该合并
                if (isConnected[i][j] == 1)
                {
                    uf.merge(i, j);
                }
            }
        }
        return uf.get_num_of_sets();
    }
};


作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/number-of-provinces/solution/547-sheng-fen-shu-liang-by-shou-hu-w9-z0wo/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

```cpp
class Solution
{
public:
    int numIslands(vector<vector<char>> &grid)
    {
        int rows = grid.size();
        int cols = grid[0].size();
        UionFind uf;
        // 1. 首先初始化所有1都为一个集合
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (grid[i][j] == '1')
                {
                    uf.add(i * cols + j);
                }
            }
        }
        // 2. 对所有的集合进行合并（相邻的1都可以进行合并）
        for (int i = 0; i < rows; i++)
        {
            for (int j = 0; j < cols; j++)
            {
                if (grid[i][j] == '1')
                {
                    int cur_root = i * cols + j;
                    if (i - 1 >= 0 && grid[i - 1][j] == '1')
                        uf.merge(cur_root, (i - 1) * cols + j);
                    if (i + 1 < rows && grid[i + 1][j] == '1')
                        uf.merge(cur_root, (i + 1) * cols + j);
                    if (j - 1 >= 0 && grid[i][j - 1] == '1')
                        uf.merge(cur_root, i * cols + j - 1);
                    if (j + 1 < cols && grid[i][j + 1] == '1')
                        uf.merge(cur_root, i * cols + j + 1);
                }
            }
        }
        return uf.get_num_of_set();
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-shou-hu-w9-pziz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [684. 冗余连接](https://leetcode-cn.com/problems/redundant-connection/)

```cpp
class Solution
{
public:
    /*  将相互连接的结点视为连通
        1. 初始化所有结点为不连通的单独的集
        2. 根据边对不同的集进行合并
        3. 如果边的两个结点在同一个集内，那就直接返回这个多余的边
    */
    vector<int> findRedundantConnection(vector<vector<int>> &edges)
    {
        UionFind uf;
        for (int i = 0; i < edges.size(); i++)
        {
            uf.add(i);
        }
        for (int i = 0; i < edges.size(); i++)
        {
            vector<int> edge = edges[i];
            if (uf.find(edge[0]) != uf.find(edge[1]))
            {
                uf.merge(edge[0], edge[1]);
            }
            else
            {
                return edge;
            }
        }
        return vector<int>{};
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/redundant-connection/solution/684-rong-yu-lian-jie-by-shou-hu-w9-6v72/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

效率不如DFS，有时间学一学DFS

```cpp
class UionFind {
private:
    unordered_map<int, int> father;

public:
    int find(int x)
    {
        int root = x;
        while (father[root] != -1) {
            root = father[root];
        }
        while (x != root) {
            int origin_father = father[x];
            father[x] = root;
            x = origin_father;
        }
        return root;
    }
    void merge(int x, int y)
    {
        int root_x = find(x);
        int root_y = find(y);
        if (root_x != root_y) {
            father[root_x] = root_y;
        }
    }
    void add(int x)
    {
        if (father.count(x) == 0) {
            father[x] = -1;
        }
    }
};
class Solution {
public:
    /**
     * 查找连通域问题，思考使用并查集，标记出所有连通位置，
     * 同时将所有的靠近边缘的连通域标记为一类，然后对除了该类的位置都变为X
    */
    void solve(vector<vector<char>>& board)
    {
        rows = board.size();
        cols = board[0].size();
        // 初始化并查集——同时定义一个边缘标记，将所有靠近边缘的都归到该标记
        UionFind uf;
        int edge = cols * rows;
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (board[i][j] == 'O')
                    uf.add(i * cols + j);
            }
        }
        uf.add(edge);
        // 合并连通域
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (board[i][j] == 'O') {
                    if (i == 0 || j == 0 || i == rows - 1 || j == cols - 1) // 边缘的统一合并到一个结点
                        uf.merge(node(i, j), edge);
                    if (i - 1 >= 0 && board[i - 1][j] == 'O')
                        uf.merge(node(i, j), node(i - 1, j));
                    if (i + 1 < rows && board[i + 1][j] == 'O')
                        uf.merge(node(i, j), node(i + 1, j));
                    if (j - 1 >= 0 && board[i][j - 1] == 'O')
                        uf.merge(node(i, j), node(i, j - 1));
                    if (j + 1 < cols && board[i][j + 1] == 'O')
                        uf.merge(node(i, j), node(i, j + 1));
                }
            }
        }
        // 根据连通域修改原矩阵
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                if (board[i][j] == 'O' && uf.find(node(i, j)) != uf.find(edge))
                    board[i][j] = 'X';
            }
        }
    }

private:
    int rows, cols;
    // 用于将二维坐标变为标记
    int node(int i, int j)
    {
        return i * cols + j;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/surrounded-regions/solution/130-bei-wei-rao-de-qu-yu-by-shou-hu-w9-ngpp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 滑动窗口(双指针)

涉及到连续子数组问题，就使用滑动窗口（双指针）

使用**两个循环**构成：
外侧循环(for)不断向右移动右侧边界right。
内侧循环(while)根据<font color='red'>窗口的限制条件</font>移动左侧边界，同时记录返回值。

模板如下：

```cpp
int longestOnes(vector<int> &nums)
{
    int res = 0;                // 保存最大的满足题目要求的 子数组/子串 长度
    int left = 0, right = 0;    //双指针，表示当前遍历的区间[left, right]，闭区间
    int sum = 0;                //用于统计 子数组/子区间 是否有效，根据题目可能会改成求和/计数
    while (right < nums.size()) // 当右边的指针没有搜索到 数组/字符串 的结尾
    {
        sum += nums[right];
        while (区间[left, right] 不符合题意) // 窗口的限制条件
        {                      // 此时需要一直移动左指针，直至找到一个符合题意的区间
            sum -= nums[left]; // 移动左指针前需要从counter中减少left位置字符的求和/计数
            left += 1;         // 真正的移动左指针，注意不能跟上面一行代码写反
        }
        // 到 while 结束时，我们找到了一个符合题意要求的 子数组/子串
        res = max(res, right - left + 1); // 需要更新结果
        right += 1;                       // 移动右指针，去探索新的区间
    }
    return res;
}
```



#### [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

```cpp
class Solution
{
public:
    /*  涉及到连续子数组问题，就使用滑动窗口（双指针）
    */
    int minSubArrayLen(int target, vector<int> &nums)
    {
        int res = INT_MAX; // 局部变量不会初始化
        int left = 0, right = 0;
        int sum = 0;
        for(;right<nums.size();right++) // 外侧循环不断使right增加
        {
            sum += nums[right]; // 将移动后的right添加到sum中——****不一定在这个位置，根据具体情况写****
            // 根据sum对left进行调整，同时计算res
            while(sum >= target){
                res = min(res, right - left + 1);
                sum -= nums[left];
                left++;
            }
        }
        return res != INT_MAX ? res : 0;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum/solution/209-chang-du-zui-xiao-de-zi-shu-zu-by-sh-p2z0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

百度一面题

```cpp
class Solution
{
public:
    /*  滑动窗口法：
        右侧索引不断增加
        1. 如果不存在当前值，就直接压入
        2. 如果存在当前值，就把左侧元素逐个删除，再压入
        注意：
            不重复，所以使用哈希集合（unordered_set）来记录滑窗内的字符
            删除左侧所有元素，按照压入顺序删除，直到删除掉当前值（具体实现看代码）
    */
    int lengthOfLongestSubstring(string s)
    {
        int res = 0;
        int left = 0, right = 0;
        unordered_set<char> occ; // 记录滑窗内的字符串
        for (; right < s.size(); right++)
        {
            // 存在当前待插入的字符，就不停的缩减左侧边界
            while (occ.find(s[right]) != occ.end())
            {
                occ.erase(s[left]);  // 由于set无重复值，那么这句等同于删除occ的最左侧函数
                // occ.erase(occ.begin());  // 不可以使用这局，因为occ.insert并不是插入末尾。。。
                left++;
            }
            occ.insert(s[right]);
            res = max(res, right - left + 1);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/solution/3-wu-zhong-fu-zi-fu-de-zui-chang-zi-chua-x86r/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [1004. 最大连续1的个数 III](https://leetcode-cn.com/problems/max-consecutive-ones-iii/)

```cpp
class Solution
{
public:
    /*  将问题转化为：
            查找一个最长子串，该数组最多允许有K个0
    */
    int longestOnes(vector<int> &nums, int k)
    {
        int res = 0;
        int left = 0, right = 0;
        int zeros = 0; // 记录0的数量
        for (; right < nums.size(); right++)
        {
            if (nums[right] == 0)
            {
                zeros++;
            }
            while (zeros > k)
            { // 从左往右删除多余的0，直到0满足要求
                if (nums[left] == 0)
                {
                    zeros--;
                }
                left++;
            }
            res = max(res, right - left + 1);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/max-consecutive-ones-iii/solution/1004-zui-da-lian-xu-1de-ge-shu-iii-by-sh-3qqm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [1208. 尽可能使字符串相等](https://leetcode-cn.com/problems/get-equal-substrings-within-budget/)

```cpp
class Solution {
public:
    /*  由于涉及连续的子字符串，所以使用滑动窗
        滑窗条件：
            内部字符串的转换预算小于最大预算
    */
    int equalSubstring(string s, string t, int maxCost) {
        int left=0, right=0;
        int res = 0;
        int cost = 0; // 滑动窗内的预算
        for(; right<s.size(); right++){
            cost += abs(s[right]-t[right]);
            while(cost > maxCost){ // 预算过大，就缩小左侧的值
                cost -= abs(s[left]-t[left]);
                left++;
            }
            res = max(res, right - left + 1);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/get-equal-substrings-within-budget/solution/1208-jin-ke-neng-shi-zi-fu-chuan-xiang-d-smf5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

所有删除相邻重复元素的题，都使用这种双指针方法。

```cpp
class Solution {
public:
    /*  双指针，分别指向重复元素的两侧位置
    */
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()==0) return 0;
        int p = 0, q = 1;
        while(q < nums.size()){
            if(nums[p] == nums[q]){
                q++;
            }else{
                nums[p+1] = nums[q];
                p++;
                q++;
            }
        }
        return p+1;
    }
};
```

#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

目前会超时，建议看下面链接思考减少时间复杂度

[简简单单，非常容易理解的滑动窗口思想](https://leetcode-cn.com/problems/minimum-window-substring/solution/tong-su-qie-xiang-xi-de-miao-shu-hua-dong-chuang-k/)

```cpp
class Solution {
public:
    /*  寻找子串必定使用：双指针滑动窗口法——>需要确定左右边界内部的东西是什么意义+合适调整左右边界
        1. l和r内部表示，该子串是否包含了全部的字符
        2. 主动调整r，如果子串不包含全部字符，r++
        3. 如果包含了全部字符串，就开始l++，直到不包含了，此时记录该子串的长度。
        至此找到了一个符合条件的子串，然后l++，继续重复以上步骤，寻找下一个子串
        辅助函数：
            需要判断是否包含了全部字符的函数
                用一个map记录当前字符需要几个，
                    如果大于0就说明还需要多个，
                    =0说明刚刚好，
                    <0说明子串中该字符有多余的。
                    如果全部字符都小于等于0，说明该子串符合条件
    */
    string minWindow(string s, string t) {
        int left = 0, right = 0;
        int lens = s.size();
        vector<int> str{0,INT_MAX}; // 记录最长子串对应的索引
        for(auto x : t){ // 初始化每个字符的所需数量
            need[x] += 1;
        }
        for(; right < lens; right++){
            need[s[right]]--;
            if(isSubstr(t)){ // 如果子串满足要求，就缩减左边界
                while(isSubstr(t)){
                    need[s[left]]++;
                    left++;
                }
                if(right-left+1 < str[1]-str[0]) // 保存最短的子串
                    str = {left, right};
            }
        }
        if(str[0] == 0 && str[1] == INT_MAX)
            return "";
        else
            return s.substr(str[0], str[1]-str[0]+1);
    }
    bool isSubstr(string t){
        bool res = true;
        for(auto x : t){
            if(need[x] > 0){
                res = false;
                break;
            }
        }
        return res;
    }
private:
    unordered_map<char, int> need;
};
```



## 前缀和

#### [724. 寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/)

![image-20210722162839559](https://gitee.com/xn1997/picgo/raw/master/image-20210722162839559.png)

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0;
        int total = accumulate(nums.begin(), nums.end(), 0);
        for(int i=0; i<nums.size(); i++){
            if(total - sum - nums[i] == sum){ // 判断当前位置是否是中心下标（这个调节是根据公式计算得到的）
                return i;
            }
            sum += nums[i]; // 计算前缀和
        }
        return -1;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/find-pivot-index/solution/724-xun-zhao-shu-zu-de-zhongxinxiabia-3tkt/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。560、437、1248差分[1094. 拼车](https://leetcode-cn.com/problems/car-pooling/)
```

```cpp
class Solution {
public:
    bool carPooling(vector<vector<int>>& trips, int capacity) {
        vector<int> delta(1001); // 记录每个站点净上下乘客数
        // 更新每个站点净上下乘客数
        for(int i=0; i<trips.size(); i++){
            delta[trips[i][1]] += trips[i][0]; // 上车所以要增加人
            delta[trips[i][2]] -= trips[i][0]; // 下车所以要减少人
        }
        // 计算每个每个站点车上的乘客数量
        int cur = 0;
        for(int i=0; i<delta.size(); i++){
            cur += delta[i];
            if(cur > capacity) return false;
        }
        return true;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/car-pooling/solution/1094-pin-che-by-shou-hu-w9-zw2g/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [974. 和可被 K 整除的子数组](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/)

```cpp
class Solution {
public:
    /*
    preS[i]：0到i的前缀和
    i到j之间数组的和为 preS[j] - preS[i-1]
    子数组可被k整除--->(preS[j]-preS[i-1])%k=0 ---> preS[j]%k == preS[i-1]%k
    
    至此，题目可以转化为preS[i]%k相等的数对共有多少组
    故，创建一个哈希表记录preS中元素出现的次数，然后计算组数即可（即组合问题C_k^2）

    注意，对于preS的0元素，还需要单独加上0的个数
    */
    int subarraysDivByK(vector<int>& nums, int k) {
        int len = nums.size();
        vector<int> preS(len, 0);
        preS[0] = nums[0] % k; preS[0] = preS[0] < 0 ? preS[0]+k : preS[0];
        for(int i=1; i<len; i++){
            preS[i] = (preS[i-1] + nums[i]) % k;
            if(preS[i] < 0) preS[i] = preS[i] + k;
        }
        unordered_map<int, int> mp;
        for(auto x : preS){
            mp[x]++;
        }
        int res = 0;
        for(auto it : mp){
            res += helper(it.second);
        }

        res += mp[0];
        return res;
    }
    // 计算x的组合数C_x^2
    int helper(int x){
        if(x == 1) return 0;
        return x * (x-1) / 2;
    }
};
```

#### [560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

```cpp
class Solution {
public:
    /*
    preS[i]：前i个数的总和（前缀和）
    i到j的总和=preS[j]-preS[i-1]=k
    因此，问题可以转化为：前缀和之差为k的组合数
    优化求解过程：使用hashmap记录preS中每个值出现的次数，如果preS[i]-k存在，那就说明存在多少个数可以与i组成k。
    */
    int subarraySum(vector<int>& nums, int k) {
        vector<int> preS(nums.size()+1, 0);
        unordered_map<int, int> mp{{0,1}}; // 初始化保证0~i可存在，必须有
        int res = 0;
        for(int i=1; i<=nums.size(); i++){
            preS[i] = preS[i-1] + nums[i-1];
            if(mp.count(preS[i]-k) != 0){
                res += mp[preS[i]-k];
            }
            mp[preS[i]]++;
        }
        return res;
    }
};
```



拓扑排序：LeetCode210
字符串：LeetCode5、20、43、93

## 二分查找

#### 二分模板（拉不拉东）

1. 统一使用<=
2. 统一使用mid-1，mid+1
3. 在相等时，
   1. 查值直接返回nums[mid]，
   2. 左侧边界（小于目标值的数量：<font color='red'>第一个大于等于target的数</font>）r=mid-1，判断l是否越界>nums.size()-1?<font color='red'>返回l</font>
   3. 右侧边界（小于等于目标值的数量-1：<font color='red'>第一个小于等于target的数</font>）l=mid+1，判断r是否越界<0?<font color='red'>返回r</font>

左侧边界定义。
如果搜索目标值为2，那么左侧边界就是1，右侧边界为3
如果搜索目标值为3，那么左侧边界就是4，右侧边界为3

| nums  | 1    | 2    | 2    | 2    | 5    | 6    |
| ----- | ---- | ---- | ---- | ---- | ---- | ---- |
| index | 0    | 1    | 2    | 3    | 4    | 5    |

```cpp
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}


int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```

#### [74. 搜索二维矩阵](https://leetcode-cn.com/problems/search-a-2d-matrix/)

```cpp
class Solution
{
public:
    /*  两次二分查找
        二分法找出小于等于target的第一个值
    */
    bool searchMatrix(const vector<vector<int>> &matrix, int target)
    {
        int row = matrix.size();
        int col = matrix[0].size();
        // 列左侧区间二分查找
        int t = 0, b = row - 1;
        while (t <= b)
        {
            int mid = t + (b - t) / 2;
            if (matrix[mid][0] > target)
                b = mid - 1;
            else if (matrix[mid][0] < target)
                t = mid + 1;
            else
                b = mid - 1;
        }
        /*  越界说明所有数都小于target
            没有找到target，说明此时t处的值大于target
            两种情况都应该-1
        */
        if(t >= row || matrix[t][0] != target)
            t--;
        if(t < 0) // <0说明不可能存在target，都比target大
            return false;
        // 行二分查找
        int l = 0, r = col - 1;
        while (l <= r)
        {
            int mid = l + (r - l) / 2;
            if (matrix[t][mid] > target)
                r = mid - 1;
            else if (matrix[t][mid] < target)
                l = mid + 1;
            else
                r = mid - 1;
        }
        if(l >= col || matrix[t][l] != target)
            l--;
        if (matrix[t][l] == target)
            return true;
        else
            return false;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/search-a-2d-matrix/solution/74-sou-suo-er-wei-ju-zhen-by-shou-hu-w9-6aon/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)***

**重点思考一下这个情况为什么是合理的**
画个图就懂了

```cpp
class Solution {
public:
    /*  二分法思路，左右有序，整体无序，因此分段讨论即可
        1.  n[mid] >= n[left]，说明mid在左段
            1.1 target < n[mid] && target > n[left], 说明target在mid左侧：否则就是mid右侧
        2. n[mid] < n[left]，说明mid在右侧
            2.1` target > n[mid] && target < n[right]，说明target在mid右侧：否则就是mid左侧
    */
    int search(vector<int>& nums, int target) {
        int left=0, right = nums.size()-1, mid=0;
        while(left <= right){
            mid = (left + right) / 2;
            if(nums[mid] == target) return mid;

            if(nums[mid] >= nums[left]){    // mid在左侧
                if(target < nums[mid] && target >= nums[left]) // target在mid左侧
                    right = mid - 1;
                else
                    left = mid + 1;
            }
            else{   // mid在右侧
                if(target > nums[mid] && target <= nums[right])    // target在mid右侧
                    left = mid + 1;
                else
                    right = mid - 1;
            }
        }
        return -1;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/33-sou-suo-xuan-zhuan-pai-xu-shu-zu-by-s-i68f/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```cpp
// 二分查找
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target)
    {
        vector<int> res { -1, -1 };
        // 查找左侧位置
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                right = mid - 1;
            }
        }
        if (left >= nums.size() || nums[left] != target)
            res[0] = -1;
        else
            res[0] = left;
        // 查找右侧位置
        left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        if (right < 0 || nums[right] != target)
            res[1] = -1;
        else
            res[1] = right;
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/34-zai-pai-xu-shu-zu-zhong-cha-zhao-yuan-uqu0/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## BFS

#### [529. 扫雷游戏](https://leetcode-cn.com/problems/minesweeper/)

定义递归函数 dfs(x, y) 表示当前在 (x,y) 点，执行扫雷规则的情况，我们只要按照上面理出来的情况来进行模拟即可，在$cnt$ 为零的时候，对当前点相邻的未挖出的方块调用递归函数，否则将其改为数字，结束递归。

```cpp
class Solution {
public:
    int dir_x[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };
    int dir_y[8] = { 1, 0, -1, 0, 1, -1, 1, -1 };

    void dfs(vector<vector<char>>& board, int x, int y)
    {
        int cnt = 0;
        for (int i = 0; i < 8; ++i) {
            int tx = x + dir_x[i];
            int ty = y + dir_y[i];
            if (tx < 0 || tx >= board.size() || ty < 0 || ty >= board[0].size()) {
                continue;
            }
            // 不用判断 M，因为如果有 M 的话游戏已经结束了
            cnt += board[tx][ty] == 'M';
        }
        if (cnt > 0) {
            // 规则 3
            board[x][y] = cnt + '0';
        } else {
            // 规则 2
            board[x][y] = 'B';
            for (int i = 0; i < 8; ++i) {
                int tx = x + dir_x[i];
                int ty = y + dir_y[i];
                // 只有当前字符确定为'E'时才能继续进行递归（按规则2决定的）
                if (tx < 0 || tx >= board.size() || ty < 0 || ty >= board[0].size() || board[tx][ty] != 'E') {
                    continue;
                }
                dfs(board, tx, ty);
            }
        }
    }

    vector<vector<char>> updateBoard(vector<vector<char>>& board, vector<int>& click)
    {
        int x = click[0], y = click[1];
        if (board[x][y] == 'M') {
            // 规则 1
            board[x][y] = 'X';
        } else {
            dfs(board, x, y);
        }
        return board;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/minesweeper/solution/529-sao-lei-you-xi-by-shou-hu-w9-xbyy/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## LeetCode127、815

## DFS&回溯：：LeetCode934、685、1102、531、533、113、332、337

## 动态规划

#### [剑指 Offer 14- I. 剪绳子](https://leetcode-cn.com/problems/jian-sheng-zi-lcof/)

```cpp
class Solution {
public:
    /*   dp[i]：长度为i的绳子的最大乘积
        dp[i] = max(dp[i], dp[j][dp[i-j]])
    */
    int cuttingRope(int n) {
        vector<int> dp(n+1, 0);
        // 特殊情况下的处理（m必须大于1）
        if(n == 2) return 1;
        if(n == 3) return 2;
        // 普通情况下的初始化（可以切也可以不切）
        for(int i=0; i<=n && i<=3; i++){
            dp[i] = i;
        }
        for(int i=4; i<=n; i++){
            for(int j=2; j <= i/2; j++){
                dp[i] = max(dp[i], dp[j]*dp[i-j]);
            }
        }
        return dp[n];
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/jian-sheng-zi-lcof/solution/jian-zhi-offer-14-i-jian-sheng-zi-by-sho-dll1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 状态：第i天，目前有没有持股{0,1}
        // dp[i][j]：第i天状态为j情况下，剩余的钱数
        // dp[i][0] = dp[i-1][0], dp[i-1][1] + prices[i] 
        // dp[i][1] = max(dp[i-1][1], - prices[i])
        vector<vector<int>> dp(prices.size(), vector<int>(2,0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i=1; i<prices.size(); ++i){
            /*只有上一天有股票才能更新今天也有股票的情况，如果使用上一天不持有股票的结果，由于上一天不持有股票会被更新不为0，就会出错*/
            // 不持有股票（卖出）==上一天不持有股票赚的钱， 上一天持有股票+今天卖出的钱=今天卖赚的钱
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // 持有股票==上一天持有股票赚的钱， 上一天不持有股票-今天买入赚（赔）的钱
            dp[i][1] = max(dp[i-1][1], - prices[i]);
        }
        return dp[prices.size()-1][0];
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/121-mai-mai-gu-piao-de-zui-jia-shi-ji-by-tp8h/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        // 状态：第i天，目前有没有持股{0,1}
        // dp[i][j]：第i天状态为j情况下，剩余的钱数
        // dp[i][0] = dp[i-1][0], dp[i-1][1] + prices[i] 
        // dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])  和121只有这一个地方不一样
        vector<vector<int>> dp(prices.size(), vector<int>(2,0));
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i=1; i<prices.size(); ++i){
            /*只有上一天有股票才能更新今天也有股票的情况，如果使用上一天不持有股票的结果，由于上一天不持有股票会被更新不为0，就会出错*/
            // 不持有股票（卖出）==上一天不持有股票赚的钱， 上一天持有股票+今天卖出的钱=今天卖赚的钱
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            // 持有股票==上一天持有股票赚的钱， 上一天不持有股票-今天买入赚（赔）的钱
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
        }
        return dp[prices.size()-1][0];
    }
};
```

#### [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

```cpp
class Solution {
public:
    /*
    状态定义：
        0: 不持股   
        1: 持股
        0，1，2: 已经卖出过几次股票，包括今天的
    状态转移：
        dp[i][0][0]=0
            未持股，未卖出过股票：说明从未进行过买卖，利润为0
        dp[i][0][1]=max(dp[i-1][1][0]+prices[i],dp[i-1][0][1])
            未持股，卖出过1次股票：可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）
        dp[i][0][2]=max(dp[i-1][1][1]+prices[i],dp[i-1][0][2])
            未持股，卖出过2次股票:可能是今天卖出，也可能是之前卖的（昨天也未持股且卖出过）
        dp[i][1][0]=max(dp[i-1][0][0]-prices[i],dp[i-1][1][0])
            持股，未卖出过股票：可能是今天买的，也可能是之前买的（昨天也持股）
        dp[i][1][1]=max(dp[i-1][0][1]-prices[i],dp[i-1][1][1])
            持股，卖出过1次股票：可能是今天买的，也可能是之前买的（昨天也持股）
        dp[i][1][2]=float('-inf')
            持股，卖出过2次股票：最多交易2次，这种情况不存在
    */
    int maxProfit(vector<int>& prices) {
        // 必须初始化为INT_MIN，确保这些不可能数据不会影响最终的结果
        vector<vector<int>> dp(2, vector<int>(3, INT_MIN));
        dp[0][0] = 0;
        dp[1][0] = -prices[0];
        // 其他情况都不存在，不再进行初始化
        for(int i=1; i<prices.size(); ++i){
            dp[0][0] = 0;
            dp[0][1] = max(dp[0][1], dp[1][0] + prices[i]);
            dp[0][2] = max(dp[0][2], dp[1][1] + prices[i]);
            dp[1][0] = max(dp[1][0], dp[0][0] - prices[i]);
            dp[1][1] = max(dp[1][1], dp[0][1] - prices[i]);
            dp[1][2] = INT_MIN;
        }
        // 最后不定是卖出两次，有可能不卖和卖出一次是最大收益
        return max(max(dp[0][1], dp[0][2]), dp[0][0]);
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/solution/123-mai-mai-gu-piao-de-zui-jia-shi-ji-ii-e94x/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

```cpp
class Solution {
public:
    // 将循环问题，转换为两个无环问题
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        return max(myRob(nums, 0, nums.size()-2), // 第一间偷，最后一间不能偷
                myRob(nums, 1, nums.size()-1));   // 第一间不偷，最后一间偷不偷都可以
    }
    // start,end确定搜索范围，指定要搜索哪几个房间
    int myRob(vector<int>& nums, int first, int last){
        vector<int> dp(nums.size(), 0); // dp[i]：前i间房子被偷的最高金额
        /*  第i间被偷， dp[i] = dp[i-2] + nums[i]
            第i间没被偷 dp[i] = dp[i-1]
        */
        // if(first == last) return nums[first]; // 只有一间房
        // dp[first] = nums[first];
        // dp[first+1] = max(nums[first], nums[first+1]);
        int pre1 = 0, pre2 = 0;
        for(int i=first; i <= last; i++){
            // dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
            int cur = max(pre1, pre2 + nums[i]);
            pre2 = pre1;
            pre1 = cur;
        }
        return pre1;
        // return dp[last];
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/house-robber-ii/solution/213-da-jia-jie-she-ii-by-shou-hu-w9-q885/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [62. 不同路径](https://leetcode-cn.com/problems/unique-paths/)

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // i,j网络到右下角有多少种路径
        vector<vector<int>> dp(m, vector<int>(n, 1)); // dp[0][...]=dp[...][0]=1
        for(int i=1; i<m; i++){
            for(int j=1; j<n; j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/unique-paths/solution/62-bu-tong-lu-jing-by-shou-hu-w9-89r3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [63. 不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

```cpp
class Solution {
public:
    // 相比62只是增加了一个对于障碍的单独处理
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int M=obstacleGrid.size();
        int N=obstacleGrid[0].size();
        vector<vector<int>> dp(M, vector<int>(N, 1));
        // 初始化dp[...][0],dp[0][...] 只有一条路径，且中间一旦出现障碍，则后续路径数全部为0
        bool have_obstacle = false;
        for(int i=0; i<M; i++){
            if(have_obstacle || obstacleGrid[i][0]){
                have_obstacle = true;
                dp[i][0] = 0;
            }
        }
        have_obstacle = false;
        for(int i=0; i<N; i++){
            if(have_obstacle || obstacleGrid[0][i]){
                have_obstacle = true;
                dp[0][i] = 0;
            }
        }
        // 状态转移
        for(int i=1; i<M; i++){
            for(int j=1; j<N; j++){
                if(obstacleGrid[i][j] == 1) // 如果该处有障碍，直接将该处的路径数置为0
                    dp[i][j] = 0;
                else // 无障碍时，等于周围路径之和
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[M-1][N-1];
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/unique-paths-ii/solution/63-bu-tong-lu-jing-ii-by-shou-hu-w9-xxb4/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

```cpp
class Solution {
public:
    /*  动态规划
        注意：动态规划不一定每次都是dp[n]=dp[n-?]，这里就是根据dp[n]去更新dp[n+?]
    */
    bool wordBreak(string& s, vector<string>& wordDict)
    {
        vector<bool> dp(s.size() + 1, false); // 表示 s 的前 i 位**是否**可以用 wordDictwordDict 中的单词表示
        dp[0] = true;
        // 外循环：遍历每一个索引位置
        for (int i = 0; i < s.size(); i++) {
            if (!dp[i])
                continue;
            /* 内循环：状态转移（从当前位置开始，判断该位置是否是某个单词的起始位置）
                    如果当前位置存在一个在字典里的数，就把对应位置置true
            */
            for (auto& word : wordDict)
                if (word.size() + i <= s.size() && s.substr(i, word.size()) == word)
                    dp[i + word.size()] = true;
        }
        return dp[s.size()];
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/word-break/solution/139-dan-ci-chai-fen-by-shou-hu-w9-a878/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [2140. 解决智力问题](https://leetcode-cn.com/problems/solving-questions-with-brainpower/)***

字节笔试题

```cpp
class Solution {
public:
    /* 反向递归
    dp[i]：i到n-1的最高分数
    i不做：dp[i] = dp[i+1]
    i做了：dp[i] = dp[i+skip+1] + w[i] 这里的i+skip+1必须不能越界
    */
    long long mostPoints(vector<vector<int>>& questions) {
        int n = questions.size();
        vector<long long> dp(n, 0);
        dp[n-1] = questions[n-1][0];
        for(int i=n-2; i>=0; i--){
            int skip = questions[i][1]; // 当前位置解决后需要跳过的步数
            if(i+skip+1 < n)
                dp[i] = max(dp[i+1], dp[i+skip+1]+questions[i][0]);
            else
                dp[i] = max(dp[i+1], static_cast<long long>(questions[i][0]));
        }
        return dp[0];
    }
};
```



#### [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)***

$O(N^2)$的动态规划解法，好理解

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        // dp[i]：以nums[i]结尾的最长严格递增子序列的长度
        int N = nums.size();
        vector<int> dp(N, 1); // 所有元素置 1，含义是每个元素都至少可以单独成为子序列，此时长度都为 1
        // dp[i]为dp前i-1个中的最大值（如果能接上+1，否则维持原值）
        for(int i=0; i<N; ++i){
            // 内循环，进行逐个状态转移
            for(int j=0; j<i; ++j){
                if(nums[i] > nums[j]){
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/300-zui-chang-di-zeng-zi-xu-lie-by-shou-pm134/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

$O(nlogn)$
动态规划+二分法优化
（由于传统DP，内循环暴力比大小，自然而然想到使用二分法加速查找过程；二分法又需要一个递增的序列；
因此，引出如何重新定义状态变量，来实现一个递增的序列，同时还能容易计算出最长子序列的长度）

```cpp
class Solution {
public:
    /*  DP
        tails[i]: 长度为i+1的最长递增子序列的尾部值。（必定是递增序列）
        用len记录当前最长的递增子序列长度
        遍历nums,
            如果nums[j]是tails中最大的就直接添加到后面，
            如果tails[i-1] <= x <= tails[i]，那么更新 tails[i] = x
        具体还是看K神的解析
    */
    int lengthOfLIS(vector<int>& nums) {
        vector<int> tails(nums.size(), 0);
        int len = 0;
        for(int num : nums){
            // 二分查找num在tails中的位置
            int l=0, r=len;
            while(l < r){
                int mid = (l+r)/2;
                if(tails[mid] < num) l = mid + 1;
                else r = mid;
            }
            // 此时tails[l] >= num，看l的改变条件可以知道**
            tails[l] = num;
            if(l == len) len++; // 说明此时tails内没有比他大的，需要扩展子序列长度
        }
        return len;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/300-zui-chang-di-zeng-zi-xu-lie-by-shou-zzcb8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [646. 最长数对链](https://leetcode-cn.com/problems/maximum-length-of-pair-chain/)

```cpp
class Solution {
public:
    // 这里数据是无序的，所以需要进行排序，变成最长递增子序列问题
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [](vector<int> x, vector<int> y)->bool{return x[0] < y[0];});
        vector<int> dp(pairs.size(), 1);
        for(int i=0; i<pairs.size(); ++i){
            for(int j=0; j<i; ++j){
                if(pairs[j][1] < pairs[i][0])
                    dp[i] = max(dp[i], dp[j]+1);
            }
        }
        return *max_element(dp.begin(), dp.end());
    }
};
```



#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)***

$dp[i][j] $代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数

所以，

当 $word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]$；

当 $word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1$

其中，$dp[i-1][j-1]$ 表示替换操作，$dp[i-1][j] $表示删除操作，$dp[i][j-1] $表示插入操作。

注意，针对第一行，第一列要单独考虑，我们引入 '' 下图所示：

<img src="https://pic.leetcode-cn.com/76574ab7ff2877d63b80a2d4f8496fab3c441065552edc562f62d5809e75e97e-Snipaste_2019-05-29_15-28-02.png" alt="Snipaste_2019-05-29_15-28-02.png" style="zoom:50%;" />

第一行，是 word1 为空变成 word2 最少步数，就是插入操作

第一列，是 word2 为空，需要的最少步数，就是删除操作

```c++
class Solution {
public:
    /*
        dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数
        所以，
        当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；
        当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1
        其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。
    */
    int minDistance(string word1, string word2) {
        int n1 = word1.size();
        int n2 = word2.size();
        vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));
        // 第一行
        for (int j = 1; j <= n2; j++) 
            dp[0][j] = dp[0][j - 1] + 1;
        // 第一列
        for (int i = 1; i <= n1; i++) 
            dp[i][0] = dp[i - 1][0] + 1;

        for (int i = 1; i <= n1; i++) {
            for (int j = 1; j <= n2; j++) {
                if (word1[i - 1] == word2[j - 1]) 
                    dp[i][j] = dp[i - 1][j - 1];
                else 
                    dp[i][j] = min(min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }
        }
        return dp[n1][n2];  
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/edit-distance/solution/72-bian-ji-ju-chi-by-shou-hu-w9-g0y2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

对“$dp[i-1][j-1] $表示替换操作，$dp[i-1][j] $表示删除操作，$dp[i][j-1] $表示插入操作。”的补充理解：

以 word1 为 "horse"，word2 为 "ros"，且 $dp[5][3] $为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：

(1) $dp[i-1][j-1]$，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）

(2)$ dp[i$][j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作

(3) $dp[i-1$][j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符

#### [1143. 最长公共子序列](https://leetcode-cn.com/problems/longest-common-subsequence/)

和72编辑距离只差了一个+1

```cpp
class Solution {
public:
	/*	动态规划：判断两个字符串子串的最长公共子序列
	*	双指针判断字符是否相等
	*/
	int longestCommonSubsequence(string text1, string text2) {
		int n1 = text1.size(), n2 = text2.size();
		// dp[i][j]：s1的前i个字符和s2的前j个字符 的最长公共子串的长度
		vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));
		// dp[...][0]=dp[0][...]=0
		for (int i = 1; i <= n1; ++i) {
			for (int j = 1; j <= n2; ++j) {
				if (text1[i-1] == text2[j-1]) { // 第i个字符匹配成功（0索引对应第1个字符）
					dp[i][j] = 1 + dp[i - 1][j - 1];
				}
				else { // 匹配失败，就还是原来的长度
					dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); // 去掉dp[i-1][j-1]是因为求最大值，而他肯定小于max()内的两个
				}
			}
		}
		return dp[n1][n2];
	}
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/longest-common-subsequence/solution/1143-zui-chang-gong-gong-zi-xu-lie-by-sh-ftua/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



**361、1230这两个是会员题**

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

momenta二面

```cpp
class Solution {
public:
    /*  动态规划
        相比最大字串问题，这里由于负数的存在，导致最小值可能变成最大值，最大值变成最小值
        因此需要两个dp数组，分别记录--以第i个元素结尾--的最大/最小的连续子数组和
        状态转移：
            1. 正数，选择当前值或者乘以以前的值
            2. 负数，最大值与最小值相互考虑
    */
    int maxProduct1(vector<int>& nums) {
        vector<int> dp_max(nums.size(), 0);
        vector<int> dp_min(nums.size(), 0);
        dp_max[0] = dp_min[0] = nums[0];
        for(int i = 1; i < nums.size(); i++){
            if(nums[i] >= 0){ // 选最大最小值
                dp_max[i] = max(dp_max[i-1] * nums[i], nums[i]);
                dp_min[i] = min(dp_min[i-1] * nums[i], nums[i]);
            }else{  // 互相考虑最大最小值
                dp_max[i] = max(max(dp_max[i-1] * nums[i], nums[i]), dp_min[i-1] * nums[i]);
                dp_min[i] = min(min(dp_max[i-1] * nums[i], nums[i]), dp_min[i-1] * nums[i]);
            }
        }
        return *max_element(dp_max.begin(), dp_max.end());
    }
    /*  优化
        可以发现不需要判断数字正负，统一使用<0时的状态转移方程即可
        由于dp[i]只和dp[i-1]相关，所以可以使空间复杂度变为O(1)
    */
    int maxProduct(vector<int>& nums) {
        int i_max, i_min, res;
        res = i_max = i_min = nums[0];
        for(int i = 1; i < nums.size(); i++){
            int temp_i_max = i_max;
            i_max = max(max(i_max * nums[i], nums[i]), i_min * nums[i]);
            i_min = min(min(temp_i_max * nums[i], nums[i]), i_min * nums[i]);
            res = max(i_max, res);
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/maximum-product-subarray/solution/152-cheng-ji-zui-da-zi-shu-zu-by-shou-hu-c7tv/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [376. 摆动序列](https://leetcode-cn.com/problems/wiggle-subsequence/)

```cpp
class Solution {
public:
    /* 参考：https://leetcode-cn.com/problems/wiggle-subsequence/solution/tan-xin-si-lu-qing-xi-er-zheng-que-de-ti-jie-by-lg/
    up[i]：num[0:i]最后两个字符为上升情况时，对应的最长子序列的长度
    down[i]：num[0:i]最后两个字符为下降情况时，对应的最长子序列的长度
    1、num[i] > num[i-1]
        up[i] = down[i-1] + 1
        down[i] = down[i-1]
    2、<同上
    3、==时，都不变
    */
    int wiggleMaxLength(vector<int>& nums) {
        int lens = nums.size();
        vector<int> up(lens, 1), down(lens, 1);
        for(int i=1; i<lens; i++){
            if(nums[i] > nums[i-1]){
                up[i] = down[i-1] + 1;
                down[i] = down[i-1];
            }
            else if(nums[i] < nums[i-1]){
                down[i] = up[i-1] + 1;
                up[i] = up[i-1];
            }
            else{
                down[i] = down[i-1];
                up[i] = up[i-1];
            }
        }
        return max(down[lens-1], up[lens-1]);
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/wiggle-subsequence/solution/376-bai-dong-xu-lie-by-shou-hu-w9-dmvm/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

更多背包问题详细可看[](G:\坚果云同步文件夹\163邮箱合并\NoteBook\算法基础\总结\数据结构与算法\)

```cpp
class Solution {
public:
    /*  完全背包问题
    dp[i][j]：前i个，组成j的，组合数
        dp[i][j] = 
            dp[i-1][j] + # 不选coins[i-1]
            dp[i][j-coins[i-1]] # 选coins[i-1]（只有这里和0-1背包不同，这里是i而0-1背包是i-1，因为可重复所以是i不是i-1）
    优化：
        dp[j] = dp[j] + # 由于没有使用之前的数据，所以这里正序倒序都一样
            dp[j-coins[i]] # 由于这个用的i，所以要是正序，和0-1背包的倒序原理一致
    */
    int change(int amount, vector<int>& coins) {
        vector<vector<int>> dp(coins.size()+1, vector<int>(amount+1, 0));
        dp[0][0] = 1;
        for(int i=1; i<=coins.size(); i++){
            for(int j=0; j<= amount; j++){
                if(j-coins[i-1] >= 0)
                    dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
                else
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[coins.size()][amount];
    }
};
```

#### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

```cpp
using ULL =  unsigned long long;
class Solution {
public:
    /*
    与完全背包不同的是这里的组合有*顺序*
    dp[i][j]：长度为i的数组，何为target的，种类数（这里i指长度，而不是数组的前i个数）
    根据第i个数的种类不同，写出状态转移方程：
        dp[i][j] += dp[i-1][j-x] x为数组中的数
    最终结果是所有的和为j的种类和，即dp[i][target]
    */
    int combinationSum4(vector<int>& nums, int target) {
        int len = target; // 因为题目给定的条件说明组合最长为target
        vector<vector<ULL>> dp(len + 1,vector<ULL>(target + 1,0));
        dp[0][0] = 1;
        int res = 0;
        for(int i=1; i<=len; i++){
            for(int j=0; j<=target; j++){
                for(auto x : nums){
                    if(j-x >= 0)
                        dp[i][j] += dp[i-1][j-x];
                }
            }
            res += dp[i][target];
        }
        return res;
    }
};

class Solution {
public:
    /*  dp[i][j]: 前i个物品，组成j的总组合数
        dp[i][j] = dp[i-1][j] + dp[i][j-num[j]]
        由于是完全背包问题：所以外循环为背包迭代，内循环为物品迭代，只有这样才能保证物品可以按一定顺序放入背包
所以程序里的i和j与上面的完全相反
    */
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target+1, 0);
        dp[0] = 1;
        for(int i=1; i<=target; ++i){
            for(int j=0; j<nums.size(); ++j){
                if(i-nums[j] >= 0 && dp[i - nums[j]] < INT_MAX -dp[i] ) // 后面这个条件是为了防止数组越界，不用管
                    dp[i] += dp[i-nums[j]];
            }
        }
        return dp[target];
    }
};
```

#### [1186. 删除一次得到子数组最大和](https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/)

```cpp
class Solution {
public:
    int maximumSum(vector<int>& arr) {
        /* 状态
            f[i]：不删除任何元素时的连续子序列最大值, f[i] = max(f[i-1]+arr[i], arr[i])
            g[i]：删除其中一个元素时的子序列最大值
                1. 删除i,说明[0,i-1]都没有删除              g[i] = f[i-1]
                2. 删除的前面的，说明此时该位置元素应该添加上   g[i] = g[i-1]+arr[i]
        */
        vector<int> f(arr.size(), 0);
        vector<int> g(arr.size(), 0);
        // 子数组不能为空，所以初始化为第一个数
        f[0] = arr[0];
        // 对于g[1] = max(g[0]+arr[1], f[0]), 因此g[1]必须选择f[0]才行，所以g[0]必须足够小
        g[0] = -1e4;
        int ret=arr[0]; // 记录最大值
        for(int i=1; i<arr.size(); i++){
            f[i] = max(f[i-1]+arr[i], arr[i]);
            g[i] = max(f[i-1], g[i-1]+arr[i]);
            ret = max(ret, max(f[i], g[i])); // 最大值必定是删或不删中的一个
        }
        return ret;
    }
};
```

#### 矩阵连乘最小乘法次数

小红书面试题

```cpp

/*
问题：求A0*...*An-1所需要的最小乘法次数
    m[i][0,1]：Ai的行和列数
解答：
    dp[i][j]：Ai到Aj之间所需要的最小乘法次数
    dp[i][j] = min(dp[i][k] + dp[k+1][j] + m[i][0]*m[k+1][0]*m[j][1], k∈[i,j) )
    这里i∈[0,n)，j∈[i,n)，k∈[i,j)
    此时，如果使用上面的边界条件是不对的，因为dp[k+1][j]是没有计算过的，因此不能进行状态转移
    因此，增加一个遍历条件，l∈[2,n]：区间长度从2到n进行遍历，确保状态转移时所有变量都已经计算好了
    此时，l∈[2,n]，0 <= i <= j < n，其中j=i+l-1，k∈[i,j)
*/
int matrix_mul(vector<vector<int>>& matrix) {
    int n = matrix.size();
    vector<vector<int>> dp(n, vector<int>(n, INT_MAX/2));
    for(int i=0; i<n; i++) dp[i][i] = 0;
    for(int l=2; l<=n; l++){
        for(int i=0; i+l-1<n; i++){
            int j=i+l-1;
            for(int k=i; k<j; k++){
                dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + matrix[i][0]*matrix[k][1]*matrix[j][1]);
            }
        }
    }
    return dp[0][n-1];
}
```



## 贪心算法：LeetCode55、435、621、452

#### [135. 分发糖果](https://leetcode-cn.com/problems/candy/)

```cpp
class Solution {
public:
    /*  贪心算法
            从左到右：满足右侧孩子高于左侧孩子
            从右到左：满足左侧孩子高于右侧孩子
    */
    int candy(vector<int>& ratings) {
        vector<int> nums(ratings.size(), 1);
        // left --> right
        for(int i=1; i<ratings.size(); i++){
            if(ratings[i] > ratings[i-1]){
                nums[i] = max(nums[i], nums[i-1]+1);
            }
        }
        // right --> left
        for(int i=ratings.size()-2; i>=0; i--){
            if(ratings[i] > ratings[i+1]){
                nums[i] = max(nums[i], nums[i+1]+1);
            }
        }
        return accumulate(nums.begin(), nums.end(),0);
    }
};
```



## 字典树（已放弃）

**字典数节点结构：**（自身代表一个字母，同时指向他后一个字母）
字幕映射表：26个指针，分别指向26个字母（通过指针的索引就可以确定下一个单词是哪个）
bool——可以不需要：记录该结点是否是一个字符串的结束
构造函数：将next指向nullptr，否则会报错。

**字典树：**
就是以上述结构生成的类，包含了**结点插入**等方法。
结点插入：遍历插入字符串的每一个字符，然后递归的往下创建后续的结点。
前缀查找——可能不需要：遍历待查字符串的每一个字符，递归的搜索，判断是否存在即可。

**使用场景：**
需要大量地判断某个字符串**是否是给定单词列表中的前缀/后缀**。
把单词倒着插入，就可以搜后缀了。

#### [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)——前缀树模板

最基础的前缀树实现方法：记住这个实现，后续都在这个基础上进行修改。
（记住这个模板，包括insert和search）

```cpp
struct TrieNode
{
    TrieNode *next[26]; //字母映射表
    bool isEnd;         //该结点是否是一个串的结束

    // 初始化结点信息
    TrieNode()
    {
        isEnd = false;
        // 子节点初始化为空指针
        for (int i = 0; i < 26; i++)
        {
            next[i] = nullptr;
        }
    }
};
class Trie
{
private:
    TrieNode *root = new TrieNode(); // 记录当前结点
    //（必须使用new TrieNode构建，只有这样才能使用自定义的构造函数初始化，否则会使用默认的拷贝构造，从而造成next变量无法指向nullptr，产生错误）
public:
    /** Initialize your data structure here. */
    Trie() {}

    /** 插入单词 */
    void insert(string word)
    {
        TrieNode *node = root;
        // 逐级向下创建链表，一个字母代表一个结点
        for (char c : word)
        {
            if (node->next[c - 'a'] == nullptr)
            {
                node->next[c - 'a'] = new TrieNode();
            }
            node = node->next[c - 'a'];
        }
        // 最后一个结点置为true，表示该串结束
        node->isEnd = true;
    }

    /** 查找是否存在该单词 */
    bool search(string word)
    {
        TrieNode *node = root;
        // 向下查找，如果某个字符不存在就返回false
        for (char c : word)
        {
            node = node->next[c - 'a'];
            if (node == nullptr)
            {
                return false;
            }
        }
        // 返回最后一个字符的状态，是否是该串结尾
        return node->isEnd;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix)
    {
        // 同search
        TrieNode *node = root;
        for (char c : prefix)
        {
            node = node->next[c - 'a'];
            if (node == nullptr)
            {
                return false;
            }
        }
        return true;
    }
};

/**
 * Your Trie object will be instantiated and called as such:
 * Trie* obj = new Trie();
 * obj->insert(word);
 * bool param_2 = obj->search(word);
 * bool param_3 = obj->startsWith(prefix);
 */

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/208-shi-xian-trie-qian-zhui-shu-by-shou-i9xxe/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [820. 单词的压缩编码](https://leetcode-cn.com/problems/short-encoding-of-words/)

将问题转换为求后缀是否相同，从而使用字典树

```cpp
/** 
 * 将问题转换为查看是否存在后缀相同的字符串，且只取其中最长的字符串计算最终的最小助记字符串 s 的长度 
 * 因此，可以使用字典树来查找相同后缀的字符串（插入的单词变为逆序即可）
*/
struct TrieNode
{
    TrieNode *next[26];
    TrieNode()
    {
        for (int i = 0; i < 26; i++)
        {
            next[i] = nullptr;
        }
    }
};
class Trie
{
private:
    TrieNode *root = new TrieNode();

public:
    int res = 0; // 根据该题所设置的变量，用于记录返回的值
    void insert(string word)
    {
        TrieNode *node = root;
        bool isNew = false;
        // 倒着插入单词
        for (int i = word.size() - 1; i >= 0; i--)
        {
            char cur_c = word[i];
            if (node->next[cur_c - 'a'] == nullptr)
            {
                // 新建了结点，说明是有新单词存在
                isNew = true;
                node->next[cur_c - 'a'] = new TrieNode();
            }
            node = node->next[cur_c - 'a'];
        }
        if (isNew)
        {
            res += word.size() + 1;
        }
    }
};
class Solution
{
public:
    int minimumLengthEncoding(vector<string> &words)
    {
        // 将字符串从大到小排序，确保先压入长的字符串，再压入小的字符串（只记录长字符串的长度即可）
        // sort(words.begin(), words.end(), [](string &x, string &y) -> bool
        //      { return x.size() > y.size(); });
        sort(words.begin(), words.end(), [](string &x, string &y) -> bool
             { return x.size() > y.size(); });
        Trie *trie = new Trie();
        for (auto word : words)
        {
            trie->insert(word);
        }
        return trie->res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/short-encoding-of-words/solution/820-dan-ci-de-ya-suo-bian-ma-by-shou-hu-tyemb/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [648. 单词替换](https://leetcode-cn.com/problems/replace-words/)

```cpp
struct TrieNode
{
    TrieNode *next[26];
    bool isEnd = false;
    TrieNode()
    {
        for (int i = 0; i < 26; i++)
        {
            next[i] = nullptr;
        }
    }
};
class Trie
{
private:
    TrieNode *root = new TrieNode();

public:
    void insert(string word)
    {
        TrieNode *node = root;
        for (int i = 0; i < word.size(); i++)
        {
            char cur_c = word[i];
            if (node->next[cur_c - 'a'] == nullptr)
            {
                node->next[cur_c - 'a'] = new TrieNode();
            }
            node = node->next[cur_c - 'a'];
        }
        // 最后一个结点置为true，表示该串结束
        node->isEnd = true;
    }
    /**
     * 从字典树中查找word的最短相同前缀
    */
    string search(string word)
    {
        TrieNode *node = root;
        string res;          // 待返回的前缀
        bool b_find = false; // 是否在字典树中找到对应的字符串
        for (auto c : word)
        {
            if (node->next[c - 'a'] == nullptr)
            { // 不存在前缀树，直接跳出
                break;
            }
            else
            { // 存在前缀树，就记录当前结点，并递归下一个字符
                node = node->next[c - 'a'];
                res += c;
                if (node->isEnd)
                { // 如果已经到了前缀一个字符，就直接退出，且标记为已经找到对于的前缀
                    b_find = true;
                    break;
                }
            }
        }
        if (b_find)
            return res;
        else
            return "";
    }
};
class Solution
{
public:
    string replaceWords(vector<string> &dictionary, string sentence)
    {
        // 1 构建字典树
        Trie trie;
        for (auto d : dictionary)
        {
            trie.insert(d);
        }
        string res;
        // 2 分割字符串
        vector<string> v_words = split(sentence, " ");
        // 3 替换每个字符
        for (auto word : v_words)
        {
            string replace_word = trie.search(word);
            if (replace_word.size() != 0)
                res += replace_word + " ";
            else
                res += word + " ";
        }
        res = res.substr(0, res.size() - 1); // 去掉最后的空格
        return res;
    }

private:
    vector<string> split(string &str, const string &pattern)
    {
        vector<string> res;
        int pos;
        str += pattern;
        int sz = str.size();
        for (int i = 0; i < sz; i++)
        { // i指向查找起始位置
            pos = str.find(pattern, i);
            string s = str.substr(i, pos - i);
            res.push_back(s);
            i = pos + pattern.size() - 1; // 更新i指向下一个位置
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/replace-words/solution/648-dan-ci-ti-huan-by-shou-hu-w9-4x4d/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 树

#### [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)***

后续遍历

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
 /*     查看待查两结点-是否在当前结点两侧-，如果在就返回该结点，不在就返回空
        那么如果两节点在该结点两侧，那么该结点就是公共祖先
        如果只有一侧有，另一侧没有，那么就回溯有的一侧返回结点
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return dfs(root, p, q);
    }
    TreeNode* dfs(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == nullptr || root == p || root == q){
            return root;
        }
        // 向两侧查找
        TreeNode* left = dfs(root->left, p, q);
        TreeNode* right = dfs(root->right, p, q);
        if(left == nullptr && right == nullptr) return nullptr;
        if(left != nullptr && right == nullptr) return left;
        if(left == nullptr && right != nullptr) return right;
        return root;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/236-er-cha-shu-de-zui-jin-gong-gong-zu-x-oco8/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [剑指 Offer 36. 二叉搜索树与双向链表](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/)***

百度一面

二叉搜索树的**中序遍历**就是从小到大排序。因此就是对二叉搜索树进行中序遍历，同时利用当前结点创建链表即可。
注意头结点的确定。

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if(root == nullptr)  return nullptr;
        // 构建双向链表，同时确定头结点和尾结点
        recur(root);
        // 头尾结点相连
        head->left = pre;
        pre->right = head;
        return head;
    }
private:
    Node* head = nullptr; // 记录头结点
    Node* pre = nullptr; // 记录双向链表中位于cur左侧的点，也就是上一次迭代中的cur，如果pre=nullptr，说明cur左侧没有值，也就是说明此时的cur为头结点。
    /** 中序遍历：构建双向链表
    *   输入：当前结点，将当前结点与上个结点进行双向链接
    */
    void recur(Node* cur){
        if(cur == nullptr) return;
        recur(cur->left);

        // pre=nullptr，说明cur左侧没有值，也就是说明此时的cur为头结点
        if(pre == nullptr)
            head = cur;
        // 不相等,就将pre和cur进行双向链接
        else
            pre->right = cur;
        cur->left = pre; // 双向链接
        pre = cur; // 更新pre

        recur(cur->right); // 递归结束后，pre指向最后一个结点
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/solution/jian-zhi-offer-36-er-cha-sou-suo-shu-yu-e08wj/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    /*
    常规思路：先序遍历，使用pre记录链表前一个结点，每次递归链接到当前结点
    存在的问题：pre->right = cur，这就导致pre原来的右结点被覆盖了，而该右结点还没被遍历过，所以结果出错
    解决方法：倒序遍历，右左中，确保每次更新时，子节点已经遍历过，覆盖也无所谓。
    */
    TreeNode* pre = nullptr;
    void flatten(TreeNode* root) {
        dfs(root);
    }
    void dfs(TreeNode* node){
        if(node == nullptr) return;
        dfs(node->right);
        dfs(node->left);
        node->right = pre;
        node->left = nullptr;
        pre = node;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-deuz/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)***

完全二叉树的性质+满二叉树的结点计算
时间复杂度$O(logn*logn)$，空间复杂度$O(1)$

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    /*  完全二叉树：倒数第二层满，倒数第一层不满
        两种情况：
            左子树深度==右子树深度：左子树为满二叉树
            左子树深度 > 右子树深度：右子树为满二叉树
        完全二叉树的结点数=2^k-1
        注意：总结点数=左子树结点数+右子树结点数+1（1是当前的根节点）
    */
    int countNodes(TreeNode* root) {
        if(root == nullptr) return 0;
        int left = depth(root->left);
        int right = depth(root->right);
        if(left == right){
            int left_nums = pow(2, left) - 1;
            int right_nums = countNodes(root->right);
            return left_nums + right_nums + 1;
        }
        else{
            int left_nums = countNodes(root->left);
            int right_nums = pow(2, right) - 1;
            return left_nums + right_nums + 1;
        }
    }
    int depth(TreeNode* root){
        if(root == nullptr) return 0;
        int left = depth(root->left);
        int right = depth(root->right);
        return max(left, right) + 1;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/count-complete-tree-nodes/solution/222-wan-quan-er-cha-shu-de-jie-dian-ge-s-5cto/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

Bigo一面题

题解看这个[「手画图解」别纠结递归的细节 | 124.二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/shou-hui-tu-jie-hen-you-ya-de-yi-dao-dfsti-by-hyj8/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    /*  对于当前根节点，该子树的最大路径和为，左侧节点的提供的最大路径+右侧节点提供的最大路径+当前节点的值
        注意：当前节点提供的最大路径是以当前节点为根节点时所能提供的最大路径（即路径一端一定是该节点）
        子问题：
            获得当前节点提供的最大路径 = 左右节点的最大路径中大的那个+本身的节点
            （如果对外提供的路径小于0，就直接返回0，不让其加入路径）
    */
    int res = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return res;
    }
    int dfs(TreeNode* root){
        if(root == nullptr)  return 0;
        int left = dfs(root->left); // 左侧节点所能提供的最大路径
        int right = dfs(root->right);
        res = max(res, left + right + root->val); // 计算当前子树所能产生的最大路径和

        int ret = max(left, right) + root->val; // 计算当前节点所能提供的最大路径
        if(ret > 0) return ret;
        else return 0;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/solution/124-er-cha-shu-zhong-de-zui-da-lu-jing-h-09yb/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

 BST的**中序遍历是升序排列**的，所以如果当前结点小于前一个结点就说明不是BST

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    /*  BST的中序遍历是升序排列的，所以如果当前结点小于前一个结点就说明不是BST
    */
    long long  pre = LLONG_MIN;
    bool isValidBST(TreeNode* root) {
        if(root == nullptr) return true;
        if(!isValidBST(root->left)) return false;

        if(root->val <= pre) return false;
        pre = root->val;

        if(!isValidBST(root->right)) return false;
        return true;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/validate-binary-search-tree/solution/98-yan-zheng-er-cha-sou-suo-shu-by-shou-19opl/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [剑指 Offer 07. 重建二叉树](https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    unordered_map<int, int> dic; // 建立值和index的对应关系{value, index} 方便查找value在中序遍历的index
    vector<int> preorder; // 记录前序，方便子函数直接使用
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        this->preorder = preorder;
        // 建立dic {value index}
        for(int i=0; i<inorder.size(); ++i){
            dic[inorder[i]] = i;
        }
        // 由前序查root，由root.val+中序查左右子树的数量，由前序查左右子树的root
        return recur(0, preorder.size()-1, 0, inorder.size()-1);
    }
    /**
    * 输入：某一个子树的前序和后续范围
    * 输出：该子树
    * 重点在preorder和inorder左右范围的变化，自己举个例子思考就行了
    */
    TreeNode* recur(int pre_left, int pre_right, int in_left, int in_right){
        if(pre_left > pre_right) return nullptr;
        TreeNode* root = new TreeNode(preorder[pre_left]); // 创建根结点
        int in_index = dic[preorder[pre_left]]; // 找到root在inorder中的位置
        int size_left_subtree = in_index - in_left;
        // 递归搜索左子树
        // 前序左侧范围+1 前序右侧范围变化 后续左侧范围不变 后序右侧范围-1
        root->left = recur(pre_left + 1, pre_left + size_left_subtree, in_left, in_index - 1);
        // 递归搜索右子树
        root->right = recur(pre_left + size_left_subtree + 1, pre_right, in_index + 1, in_right);
        return root;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/solution/jian-zhi-offer-07-zhong-jian-er-cha-shu-p9g23/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





## 重要题型

#### [224. 基本计算器](https://leetcode-cn.com/problems/basic-calculator/)

**双栈：**
数据桟：记录运算值
运算符桟：记录所有的运算符

该方法可以解决所有的计算器问题。（下面程序一个都不能改，死记就行了）

```cpp
class Solution {
public:
    /*  双栈：
            nums：记录运算值及运算结果（将两个运算值弹出，并压入运算结果）
            ops：记录所有的运算符（+ - * / ()）——【栈内运算符】
        遍历过程：
            // 栈压入
            1. 遇到(，直接压入ops
            2. 遇到数字，循环读取数字（直到读到非数字 或 最后一个字符为止），并压入nums
            // 计算
            3. 遇到运算符，将栈内运算级别比它高的都运算，否则压入ops。（遇到(或者ops为空）
                如果栈内运算优先级比较低，那么压入，总会在某个时候，运算该优先级的运算符的
            4. 遇到)，对ops和nums进行计算，直到遇到(
        注意：
            考虑到开始的字符可能是+-开头，因此必须将(+换为(0+，(-换为(0-
    */

    // 设定运算符优先级
    unordered_map<char, int> oper_pri = {
        {'+', 1},
        {'-', 1},
        {'*', 2},
        {'/', 2},
        {'%', 2},
        {'^', 3},
    };
    int calculate(string s) {
        stack<long long> nums;
        stack<char> ops;
        int n = s.size();
        nums.push(0);  // -----避免开头是+-，基本开头不是+-，也不会取到0这个数字
        for(int i=0; i<n; ++i){
            if(s[i] == ' ') continue;
            else if(s[i] == '(') {
                ops.push(s[i]);
                if(s[i+1] == '+' || s[i+1] == '-') // -----避免开头是+-
                    nums.push(0);
            }
            else if(isdigit(s[i])){
                // 挨个读取整个数字
                int num = int(s[i] - '0');
                while(i+1 < n && isdigit(s[i+1])){
                    ++i;
                    num = num * 10 + int(s[i] - '0');
                }
                nums.push(num);
            }
            else if(s[i] == ')'){
                // 计算括号内的所有元素（因为此时ops中只有+-法，不会有优先级问题了，直接运算即可）
                while(ops.top() != '(')
                    cal(nums, ops);
                ops.pop();
            }
            else{
                // 将栈内运算符全部进行计算（只计算桟内优先级高的ops）必须是>=，不能是>，确保同级运算从左往右
                while(!ops.empty() && ops.top()!='(' && oper_pri[ops.top()] >= oper_pri[s[i]])
                    cal(nums, ops);
                // 压入运算符
                ops.push(s[i]);
            }
        }
        // 以上只是对括号内的式子进行了运算，并未对两头的数据进行运算：1+2+3+4，最后只会得到6+4
        // 对剩余的式子进行运算
        while(!ops.empty()){
            cal(nums, ops);
        }
        return nums.top();
    }
    // 根据数字栈和运算符栈，进行一次栈顶的运算，把计算结果压入nums中
    void cal(stack<long long>& nums, stack<char>& ops){
        // 依次弹出前运算符两侧的数字/运算符
        long long b = nums.top(); nums.pop(); 
        long long a = nums.top(); nums.pop();
        char oper = ops.top(); ops.pop();
        // 计算
        long long res = 0;
        switch(oper){
            case '+': res = a + b; break;
            case '-': res = a - b; break;
            case '*': res = a * b; break;
            case '/': res = a / b; break;
            case '%': res = a % b; break;
            case '^': res = pow(a, b); break;
        }
        // 压入结果
        nums.push(res);
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/basic-calculator/solution/224-ji-ben-ji-suan-qi-by-shou-hu-w9-hns1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

哲库一面

```cpp
class Solution {
public:
    /**
     * 最长回文子串，使用双指针思路
     * 中心扩散法：以一个中心开始向两边扩散，只要两侧相等就继续扩散
     * （需要注意需要分为两种情况，一种是奇数情况从单个字符开始，一种是偶数情况从两个字符开始
    */
    string longestPalindrome(string s)
    {
        string res;
        for (int i = 0; i < s.size(); i++) {
            string s1 = Palindrome(s, i, i);
            string s2 = Palindrome(s, i, i + 1);
            res = res.size() > s1.size() ? res : s1;
            res = res.size() > s2.size() ? res : s2;
        }
        return res;
    }
    // 获得一个回文子串
    string Palindrome(string& s, int l, int r)
    {
        while (l >= 0 && r < s.size() && s[l] == s[r]) {
            l--;
            r++;
        }
        return s.substr(l + 1, (r - 1) - (l + 1) + 1);
    }
};
```

#### [15. 三数之和](https://leetcode-cn.com/problems/3sum/)

双指针+排序$O(n^2)$
**看到数组+元素和，首要想到双指针，然后双指针的前提是排序。最后根据实际需求，选择合适的指针移动过程**

```cpp
class Solution {
public:
    /*  排序+双指针
        类似《求子序列和为0 的题》不过这里不是求子序列的和，而是指定了三个元素，左、内部、右三个值
    可以思考，使用双指针的方法——>先数组排序
        1. 数组排序
        2. 指定最左侧索引l，最右侧索引r，中间索引k=l+1
            从左向右针对每一个l执行
            1. 和>0，说明nums[r]太大，r左移 r--
            2. 和<0，说明nums[k]太小，k右移，k++
            3. 和==0，添加，为了防止出现重复解，需要同时移动r，k，r--,k++
            （所有的--，++都是指跳过重复元素的，避免出现重复的三元组）
    */
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end(), less<int>());
        int n = nums.size();
        int l=0, r=n-1, k=l+1;
        // 外侧遍历l
        for(; l<n-2; l++){
            if(nums[l] > 0) break; // 最左侧>0一定不可能存在
            if(l > 0 && nums[l] == nums[l-1]) continue; // 最左侧数字重复，跳过查找
            r = n - 1;
            k = l + 1;
            // 内侧遍历k和r
            while(k < r){
                int sum = nums[l] + nums[k] + nums[r];
                if(sum > 0){
                    while(k < r && nums[r] == nums[--r]); // --r确保可以第一次就-1
                }
                else if(sum < 0){
                    while(k < r && nums[k] == nums[++k]);
                }
                else{
                    res.push_back(vector<int>{nums[l], nums[k], nums[r]});
                    while(k < r && nums[r] == nums[--r]); // 避免重复
                    while(k < r && nums[k] == nums[++k]);
                }
            }
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/3sum/solution/15-san-shu-zhi-he-by-shou-hu-w9-hkpp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [172. 阶乘后的零](https://leetcode-cn.com/problems/factorial-trailing-zeroes/)

找规律：将结尾0的个数转为——》乘数中有几个10——》乘数中有几个五——》

```CPP
class Solution {
public:
    /** nlog_5^n
        含有 2 的因子每两个出现一次，含有 5 的因子每 5 个出现一次，所有 2 出现的个数远远多于 5，换言之找到一个 5，一定能找到一个 2 与之配对。所以我们只需要找有多少个 5。
        直接的，我们只需要判断每个累乘的数有多少个 5 的因子即可。
    */
    int trailingZeroes(int n) {
        int count = 0;
        for (int i = 1; i <= n; i++) {
            int N = i;
            while (N > 0) {
                if (N % 5 == 0) {
                    count++;
                    N /= 5;
                } else {
                    break;
                }
            }
        }
        return count;
    }
    /** 解法二 log_5^n
        每隔 5 个数，出现一个 5，每隔 25 个数，出现 2 个 5，每隔 125 个数，出现 3 个 5... 以此类推。    
        最终 5 的个数就是 n / 5 + n / 25 + n / 125 ..
    */
    int trailingZeroes(int n) {
        int count = 0;
        while (n > 0) {
            count += n / 5;
            n = n / 5;
        }
        return count;
    }
};
```

#### [面试题 02.05. 链表求和](https://leetcode-cn.com/problems/sum-lists-lcci/)

反向存放：
从两个链表头开始相加，处理进位（单位之和大于10的问题）。创建新的链表节点。然后连接节点

正向存放：
**利用栈先进后出**，计算每一位的和，累加过程处理与反向一致。每一步处理连接节点摆放位置不同。

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    //反向存放（本题）
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = new ListNode(-1); // 辅助结点
        ListNode *cur = head;
        int carry = 0, sum = 0;
        while (l1 || l2 || carry) { // 计算结束且无进位时退出
            sum = 0;
            if (l1 != NULL) {
                sum += l1->val;
                l1 = l1->next;
            }

            if (l2 != NULL) {
                sum += l2->val;
                l2 = l2->next;
            }

            sum += carry;
            ListNode *temp = new ListNode(sum % 10);
            carry = sum / 10;
            cur->next = temp;
            cur = cur->next;
        }
        return head->next;
    }

    //正向存放
    ListNode* addInList(ListNode* head1, ListNode* head2) {
        // 利用栈存储链表数据，从而从个位到高位进行计算。
        stack<int> st1, st2;
        while (head1 || head2) {
            if (head1) {
                st1.push(head1->val);
                head1 = head1->next;
            }
            if (head2) {
                st2.push(head2->val);
                head2 = head2->next;
            }
        }
        // 以下同上面的反向存放
        ListNode *head = new ListNode(-1);
        int carry = 0, sum = 0;
        while (!st1.empty() || !st2.empty() || carry != 0) {
            sum = 0;
            if (!st1.empty()) {
                sum += st1.top();
                st1.pop();
            }
            if (!st2.empty()) {
                sum += st2.top();
                st2.pop();
            }
            sum += carry;
            ListNode *cur = new ListNode(sum % 10);
            carry = sum / 10;
            cur->next = head->next;
            head->next = cur;
        }
        return head->next;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/sum-lists-lcci/solution/mian-shi-ti-0205-lian-biao-qiu-he-by-sho-j4r5/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)

```cpp
class Solution {
public:
    /** 找规律：
            乘数 num1 位数为 M，被乘数 num2 位数为 N， num1 x num2 结果 res 最大总位数为 M+N
            num1[i] x num2[j] 的结果为 tmp(位数为两位，"0x","xy"的形式)，其第一位位于 res[i+j]，第二位位于 res[i+j+1]。
    */
    string multiply(string num1, string num2) {
        int m = num1.size(), n = num2.size();
        vector<int> res(m+n, 0); // 结果最多为m+n位置
        // 从个位开始逐位相乘
        for(int i=m-1; i>=0; --i){
            int n1 = num1[i] - '0';
            for(int j=n-1; j>=0; --j){
                int n2 = num2[j] - '0';
                int mul = n1 * n2; // 乘积
                int p1 = i + j, p2 = i + j + 1; // 乘积在res上对应的位置（这个很重要）
                int sum = res[p2] + mul; // 更新对应位置
                res[p2] = sum % 10;
                res[p1] += sum / 10; // 进位，必须是+=，不能是+
            }
        }
        // 将res转化为字符串
        bool flag = false;  // false：还没有遇到数字的第一个数
        string str;
        for(int i=0; i<res.size(); ++i){
            if(res[i] != 0 || flag) {
                flag = true;
                str += res[i] + '0';
            }
        }
        return str.size() == 0 ? "0" : str;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/multiply-strings/solution/43-zi-fu-chuan-xiang-cheng-by-shou-hu-w9-ck4o/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### 栈实现队列、队列实现栈

栈实现队列：修改pop即可。弹出栈为空就将压入栈全部压入弹出栈。

队列实现栈：修改push即可。压入栈始终为空，<u>先将数据压入空栈，然后将弹出栈压入压入栈，最后交换弹出和压入栈</u>，确保弹出栈的头部始终是最新压入的数据。

[【队列】用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/solution/wu-tu-guan-fang-tui-jian-ti-jie-yong-dui-63d4/)

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)***

只能使用归并排序——因为链表可以使用快慢指针找到链表中间的位置，所以用归并。而快排需要来回交换位置，链表是无法实现的。

```cpp
// nlg(n) 归并，快排
class Solution {
public:
	// 返回新链表的头结点
	ListNode* sortList(ListNode* head) {
		// 1. 分
		// 在中间位置断开连接
		if (head == nullptr || head->next == nullptr) { // 分到最后一个位置（只有一个结点）
			return head;
		}
		// 寻找中间位置
		ListNode* slow = head, *fast = head->next; // 只有fast从next开始，才能保证偶数时，slow指向前一个结点，而不是后一个结点
		while (fast != nullptr && fast->next != nullptr) {
			fast = fast->next->next;
			slow = slow->next;
		} // slow指向中间或偏左的一个结点
		// 断开结点，分成两个链表
		ListNode* mid = slow->next;
		slow->next = nullptr;
		ListNode* left = sortList(head);
		ListNode* right = sortList(mid);
		// 2. 合
		// 无需数组那样创建一个辅助数组，这里只创建一个辅助结点，并把结果添加到该结点即可
		ListNode* new_head = new ListNode(0);
		ListNode* ret = new_head; // ret->next就是应该返回的头结点

		while (left != nullptr && right != nullptr) {
			if (left->val < right->val) {
				new_head->next = left;
				left = left->next;
			}
			else {
				new_head->next = right;
				right = right->next;
			}
			new_head = new_head->next;
		}
		// 将剩余的结节加入
        if(left != nullptr)
            new_head->next = left;
        else if(right != nullptr)
            new_head->next = right;
		return ret->next; // 第一个是辅助结点，下一个才是头结点
	}
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/sort-list/solution/148-pai-xu-lian-biao-by-shou-hu-w9-zxnp/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 括号匹配

#### [22. 括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

```cpp
class Solution {
public:
    /*  DFS
        递归规则：
            1. （任何时候都可以添加
            2. ）只有在（已经添加的数量大于）时才可以添加 ***（这个规律必须发现）
    */
    vector<string> generateParenthesis(int n) {
        dfs(string{""}, n, n);
        return res;
    }
private:
    vector<string> res;
    void dfs(string str, int left, int right){
        if(left == 0 && right == 0){ // 遍历完毕
            res.push_back(str);
        }
        if(left > 0){ // 添加（
            dfs(str + '(', left -1, right);
        }
        if(left < right){   // 添加)——现有(数量大于)
            dfs(str+')', left, right -1);
        }
        return;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/generate-parentheses/solution/22-gua-hao-sheng-cheng-by-shou-hu-w9-cvs1/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

利用栈先入后出的特性实现括号匹配————括号匹配可理解为先入后出

```cpp
class Solution {
public:
	/*	利于栈判断括号是否有效
	*/
	bool isValid(string s) {
		stack<char> st;
		for (char x : s) {
			// 左括号压入
			if (x == '(' || x == '[' || x == '{') {
				st.push(x);
			}
			// 右括号对比弹出
			else {
				if(!st.empty() && st.top() == leftOf(x)) // 右括号匹配则弹出
					st.pop();
				else
					return false;
			}
		}
		// 如果栈空了，说明匹配成功
		return st.empty();
	}
private:
	// 根据右括号查找左括号
	char leftOf(char c) {
		if (c == ')') return '(';
		else if (c == ']') return '[';
		else return '{';
	}
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/valid-parentheses/solution/20-you-xiao-de-gua-hao-by-shou-hu-w9-kkft/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [921. 使括号有效的最少添加](https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/)

```cpp
class Solution {
public:
    /** 类似括号匹配，同样需要判断左右括号什么情况下括号合法
        遇到（，期望）+1
        遇到），期望）-1；如果没有（与其匹配，那么期望（+1
    */
    int minAddToMakeValid(string s) {
        int left_need = 0, right_need = 0; // 左右括号的需求量
        for(char c : s){
            if(c == '('){
                right_need += 1;
            }
            else if(c == ')'){
                right_need -= 1;
                if(right_need < 0){ // 此时没有（与）匹配，那么就需要增加对（的需求
                    right_need = 0;
                    left_need += 1;
                }
            }
        }
        return left_need + right_need;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/minimum-add-to-make-parentheses-valid/solution/921-shi-gua-hao-you-xiao-de-zui-shao-tia-rdvs/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)***

**括号匹配只压入（即可，然后对遇到的）进行处理**

```cpp
class Solution {
public:
    /*  括号匹配：使用栈
        括号：只压入（即可，遇到）判断栈内是否为空即可判定是否匹配
        找出连续合法括号的长度：直接用）减去与其匹配的（的位置即可。因此直接压入（的索引
        
        设置start记录合法子串的左侧端点索引位置
        当s[i]='('时，直接将索引压入栈
        s[i]=')'时的情况分析：
        1. 栈为空
            说明匹配失败，合法子串的左侧端点更新为i+1: start = i+1
        2. 栈不为空
            说明匹配成功，弹出栈顶
            2.1 如果此时栈为空  
                直接计算总长度：i-start+1
            2.2 栈不为空
                直接计算对应的长度：i-st.top+1-1（因为左端点已经被弹出，所以他的索引应该是栈顶元素+1）
        ）匹配成功(此时栈不为空)：
    */
    int longestValidParentheses(string s) {
        int res = 0;
        int start = 0; // 记录合法子串的左侧端点索引位置
        stack<int> st;
        for(int i=0; i<s.size(); i++){
            if(s[i] == '(')
                st.push(i);
            else{
                if(st.empty())
                    start = i+1;
                else{
                    st.pop();
                    if(st.empty())
                        res = max(res, i - start + 1); // )()()针对这种情况的处理
                    else 
                        res = max(res, i - st.top() + 1 - 1); // 普通的情况
                }
            }
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/32-zui-chang-you-xiao-gua-hao-by-shou-hu-01tw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 面试题

#### 二分法变形题

给定一个已经排好序的字符串数组,空字符串散布在该数组中,编写一个函数寻找一个 给定字符串的位置。

```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;
int search(vector<string> s, string x)
{
    int low = 0, high = s.size();
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        // 中间为空的处理方案
        if (s[mid] == "") {
            int tmp = mid;
            while (tmp >= low && s[tmp] == "") //注意若s[mid]==""，注意右移
            {
                --tmp;
            }
            if (tmp < low) // 左侧全部为空
                low = mid + 1;
            else if (s[tmp] == x) { // low不为空
                return tmp;
            } else if (s[tmp] > x) {
                high = mid - 1;
            } else if (s[tmp] < x) {
                low = mid + 1;
            }
        }
        // 非空就正常二分
        else { 
            if (s[mid] == x)
                return mid;
            else if (s[mid] < x)
                low = mid + 1;
            else
                high = mid - 1;
        }
    }
    return -1;
}

int main()
{
    vector<string> s{
        "at", "", "", "", "ball", "", "", "car", "", "", "dad", "", ""
    };
    cout << search(s, "at") << endl;

    return 0;
}
```

#### [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

```cpp
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        if(strs.size() == 0) return "";
        string res = strs[0]; // 以第一个str初始化公共前缀
        for(int i=0; i<strs.size(); ++i){
            int j = 0;
            for(; j < res.size() && j < strs[i].size(); ++j){
                if(res[j] != strs[i][j]) break; // 从头开始逐个比较字符，不同就退出
            }
            res = res.substr(0, j); // 截取新的公共前缀
            if(res == "") break;
        }
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/longest-common-prefix/solution/14-zui-chang-gong-gong-qian-zhui-by-shou-z47q/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

排列组合问题：暴力递归+回溯**（排列组合一律使用递归）**
**对于不重复的搜索：使用used记录搜索过的点，后续搜索跳过，以空间换时间**
对于重复的搜索： 如果有顺序，就直接暴力递归；
无顺序要求，即包含元素相同视为一致，此时进行有顺序的搜索：每次遍历跳过前面已经遍历过的结点（参考39. 组合总和）

```cpp
class Solution {
public:
    /*  暴力递归+记录遍历过的结点
        排列组合一律使用递归；由于不可重复选取，因此使用一个数组，记录遍历过的结点
    */
    vector<vector<int>> permute(vector<int>& nums) {
        vector<int> path;
        vector<vector<int>> res;
        vector<bool> used(nums.size(), false);
        dfs(nums, used, path, res);
        return res;
    }
    void dfs(vector<int>& nums, vector<bool>& used, vector<int>& path, vector<vector<int>>& res){
        if(path.size() == nums.size()){ // 遍历完毕保存退出
            res.push_back(path);
            return;
        }
        for(int i=0; i<nums.size(); ++i){
            if(!used[i]){   // 没有使用过该结点，就从该结点递归
                used[i] = true;
                path.push_back(nums[i]);
                dfs(nums, used, path, res);
                path.pop_back();    // 回溯
                used[i] = false;
            }
        }
        return;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/permutations/solution/46-quan-pai-lie-by-shou-hu-w9-t4rx/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [所有组合数](https://leetcode-cn.com/problems/power-set-lcci/)***

```cpp
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<int> path;
        vector<vector<int>> res(1,vector<int>()); // 单独添加[]
        dfs(nums, path, res, 0);
        return res;
    }
    // 对于组合问题，一律都要使用start来过滤前面的元素，并记录走过的所有路径
    void dfs(vector<int>& nums, vector<int>& path, vector<vector<int>>& res, int start){
        for(int i=start; i<nums.size(); ++i){
            path.push_back(nums[i]);
            res.push_back(path); // 唯一的不同：将path保存语句放在这里，确保经过的每个路径都可以被保存
            dfs(nums, path, res, i+1); // i+1：前面的数据都不再考虑
            path.pop_back();    // 回溯
        }
        return;
    }
};
```

#### 小东分苹果

果园里有一堆苹果，一共n头(n大于1小于9)熊来分，第一头为小东，它把苹果均分n份后，多出了一个，它扔掉了这一个，拿走了自己的一份苹果，接着第二头熊重复这一过程，即先均分n份，扔掉一个然后拿走一份，以此类推直到最后一头熊都是这样(最后一头熊扔掉后可以拿走0个，也算是n份均分)。问最初这堆苹果最少有多少个。
给定一个整数n,表示熊的个数，返回最初的苹果数。保证有解。
测试样例：

> 2
> 返回：3

```cpp
int getInitial(int n) {
    int apples = n + 1; // 遍历每一个苹果
    while(1){
        int bears = n,temp = apples; // 模拟当前苹果数量下，能否实现n个熊的分配
        while(bears > 0){
            if(temp % n == 1){
                --bears;
                temp = temp - (temp - 1)/n - 1;
            }
            else break; // 不能剩余1个就直接视当前情况不合理
        }
        if(bears == 0) break; // 如果最后剩余熊没了，就说明当前苹果数目合适
        ++apples;
    }
    return apples;
}
```

#### [剑指 Offer II 078. 合并排序链表](https://leetcode-cn.com/problems/vvXgSW/)***

Bigo二面

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    /*  使用K个指针指向每个链表。每次取出K个数中最小的结点，接入链表，然后将该结点下一个节点加入这K个数中。
        由于每次都需要找到最小的那个数，所以使用小顶堆来实现，提高查找最小值的速度。
        时间复杂度：nlogk k个链表，一共n个结点
    */
    struct cmp{
        bool operator()(ListNode* x, ListNode* y){
            return x->val > y->val;
        }
    };
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        // 注意这里小顶堆是前者大于后者（和sort中的正好相反）
        // auto cmp = [](ListNode* x, ListNode* y)->bool {return x->val > y->val;}; 这种写法——这两句一点都不能变
        // priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> heap(cmp);
        priority_queue<ListNode*, vector<ListNode*>, cmp> heap; // 建议使用仿函数这种方法，易理解
        for(auto x : lists){
            if(x != nullptr) // 压入各个头结点
                heap.push(x);
        }
        while(!heap.empty()){
            ListNode* min_node = heap.top(); // 弹出最小结点
            heap.pop();
            cur->next = min_node; // 链接最小结点
            cur = cur->next;
            if(min_node->next != nullptr){ // 压入最小结点后面的结点
                heap.push(min_node->next);
            }
        }
        ListNode* res = dummy->next;
        delete dummy; dummy = nullptr; // 释放辅助结点（一般都不需要写）
        return res;
    }
};

作者：shou-hu-w9
链接：https://leetcode-cn.com/problems/vvXgSW/solution/jian-zhi-offer-ii-078-he-bing-pai-xu-lia-h5aa/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

