## extern

作用

1. 当extern与“c”在一起使用时，如：extern “C” void fun(int a,int b)则告诉编译器fun这个函数名时按着c的规则去翻译相应的函数名而不是c++的
2. 当extern 不与“c”一起修饰变量或函数时，其作用就是==声明函数或变量的作用范围==。extern的作用范围为本模块或其他模块。

## static

### static修饰内置类型变量为静态变量

1. 静态变量只初始化一次，未初始化的静态变量会默认初始化为0。

2. 静态**全局变量只在本文件可见，外部文件无法访问**。
3. 而静态**局部变量只在定义的作用域内可见，但他们的生存周期都是整个程序运行时期**。

### static修饰函数为静态函数

static修饰的函数**只允许在当前文件中使用**，在其他文件中无法找到该函数的地址。不可以被其他文件引用，且不会与其他文件中的同名函数冲突。

### **static修饰成员变量为静态成员变量**

*  所有对象(包括派生类的对象)共享同一份数据
*  在编译阶段分配内存
*  **类内声明，类外初始化**（不可使用构造函数初始化）

### **static修饰成员函数为静态成员函数**

*  所有对象共享同一个函数
*  不含this指针。**不需要通过对象便可直接访问**。
*  **静态成员函数只能访问静态成员变量**

## const

### const修饰成员函数

**常对象：**

* 声明对象前加const称该对象为常对象
* **常对象只能调用常函数**

`const Person person; //常量对象  `

==**常函数：**==

* 成员函数后加const后我们称为这个函数为**常函数**
* 常函数内==不可以修改成员属性==，只能使用数据成员，不可以对其进行修改
* 常对象只能调用常函数，不能调用普通函数
* 成员属性声明时加关键字mutable后，在常函数中依然可以修改

```cpp
void ShowPerson() const { // 常函数

}
mutable int m_B; //可修改 可变的
```

### [顶层const和底层const](https://www.cnblogs.com/penuel/p/11322557.html)             

1.顶层const表示指针本身是一个常量。（指针常量）

　　int i = 0;

　　int *const p1 = &i;

　　const int ci = 42;

代表指针指向的地址是不能变的。

2.底层const表示指针指向的对象是一个常量。（常量指针）

　　const int ci = 2;　

　　const int *p2 = &ci;

p2的值可以改变，即可以指向别的对象，但是指向的对象必须是常量。

## 关系

- static和extern不能同时修饰一个变量！
  
  - static即定义也声明，而extern只能声明
  
- const和static不能同时修饰

  C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但**当一个成员函数为static的时候，该函数是没有this指针的**。也就是说**此时const的用法和static是冲突**的。

## volatile

作用：防止对变量进行优化。

当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入 CPU  寄存器中。如果变量被装入寄存器，那么**两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量**，这会造成程序的错误执行。volatile  的意思是**让编译器每次操作该变量时一定要从内存中真正取出**，而不是使用已经存在寄存器中的值

示例：

设置变量

```cpp
volatile  BOOL  bStop  =  FALSE;
```

第一个线程

```cpp
while(  !bStop  )  {  ...  }  
bStop  =  FALSE;  
return;    
```

第二个线程

```cpp
bStop  =  TRUE;  
while(  bStop  );  //等待上面的线程终止，如果bStop不使用volatile申明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。
```

分析：

1. 如果没有volatile，编译器发现一二线程都用到了bStop，那么就会使其中一个线程从内存读数据，然后存到寄存器中，而另一个线程则直接从寄存器读取数据，这样可以加快程序的处理速度。
2. 然而，第一个线程改变了内存中的数据，而无法改变寄存器中的数据，所以第二个线程读入的依然是最开始线程一中的数据，导致数据无法全局更新，导致错误。
3. 加上volatile，就会强制不对涉及到bStop的程序进行优化，统一从内存中读取，这样线程一改变了内存中的数据，线程二从内存中也就读取到了改变后的数据。

### 标准回答

1. Volatile关键词的第一个特性：易变性。所谓的易变性，在汇编层面反映出来，就是两条语句，**下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取**。 
2. Volatile关键词的第二个特性：“不可优化”特性。volatile告诉编译器，**不要对我这个变量进行各种激进的优化，**甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。

3. Volatile关键词的第三个特性：”顺序性”，能够**保证Volatile变量间的顺序性**，编译器不会进行乱序优化。

4. C/C++ Volatile变量，与非Volatile变量之间的操作，是可能被编译器交换顺序的。C/C++ Volatile变量间的操作，是不会被编译器交换顺序的。哪怕将所有的变量全部都声明为volatile，哪怕杜绝了编译器的乱序优化，但是针对生成的汇编代码，CPU有可能仍旧会乱序执行指令，导致程序依赖的逻辑出错，volatile对此无能为力.

## override

**<u>确保该成员函数为虚函数并一定可以覆盖来自基类的虚函数</u>**。如果覆盖失败，就会报错。

1. 如果父类中不存在函数a，而子类中以为有函数a，子类就写了一个函数a。
   如果不加override不会发生报错，因为<u>编译器认为a是子类新创建的函数</u>；
   而如果加上override，就会<u>发现父类中并不存在这个函数a，所以就重写失败</u>，所以报错。

因此，优点是：确保该成员函数一定可以重写成功。

## final

虚函数后加上 final 关键字，则之后任何想覆盖该函数的行为会报错。 